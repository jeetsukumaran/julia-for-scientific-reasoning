---
date-created: 2026-02-12T01:12:49
title: "Generating sequences of values using the `range` function"
---

This is an example of a mathematical model relating $y$ values to $x$:

::: {.model-definition title="A linear model"}

$y = 6x + 4$

:::

To visualize this in Julia, we generate sets $x$ and $y$ values conforming to the above relationship and pass these to the plotting function.
These values may be generated systematically---a sequence generated by an algorithm---or stochastically---sampled from a probabilistic distribution.
Here, we will discuss the first case.

In all cases, we have to ensure that the *type* and *range* of values conform to the assumptions of the model.
In this example, 
The $x$ and $y$ values will be assumed to be, each, single-dimensional real values, $x, y \in \mathrm{R}^1$, taking values in the entire real line. 
The $y$ values here are deterministic functions of the $x$ values, and so they can be calculated from the $x$ values, once these have been generated.

## Generating a sequence of values with the `range` function

::: {.callout-note title="Range objects are algorithmic representation of ranges" .column-margin}

The actual value returned by the `range` function are not actually arrays of values, but rather a special "lazy" range object, with "lazy" here being a program design term meaning that the resources (particularly memory) will be allocated only if and when needed.
What this means is that you can construct very large collections of values, with large ranges and high resolution, but not pay the resource cost of holding all these values in memory at the same time.

```{.julia}
julia> r = range(1e-10, 1e10; step = 0.001)
1.0e-10:0.001:1.0e10
julia> length(r)
10000000000001
julia> r[begin]
1.0e-10
julia> r[end]
1.0e10
julia> r[begin + 2]
0.0020000001
julia> r[end - 4]
9.999999999996e9
julia> r[1]
1.0e-10
julia> r[2]
0.0010000001
julia> r[3]
0.0020000001
```

To actually generate the values, use the `collect` function, which will "unpack" the range object and return a `Vector` object (a single dimensional array) with the full sequence of values.

 ```{.julia}
julia> r = range(0, 10; step = 2.5)
0.0:2.5:10.0

julia> collect(r)
5-element Vector{Float64}:
  0.0
  2.5
  5.0
  7.5
 10.0
 ```


:::


We can generate a set of $x$ values over a particular range of values, continuous or otherwise, using the `range` function in Julia.
The `range` function has a number of different methods, but for our purposes we will focus on specifying the range in terms of a three parameters: a *start* value, a *stop* value, and either a *step* size (interval between consecutive values in the sequence),

```{.julia}
julia> range(0, 10; step = 1)
0:1:10
julia> range(0, 10; step = 0.2)
0.0:0.2:10.0
julia> range(-10, 10; step = 2)
-10:2:10
```
or *length* (number of values) in the sequence,

```{.julia}
julia> range(0, 10; length = 11)
0.0:1.0:10.0
julia> range(0, 10; length = 5)
0.0:2.5:10.0
julia> range(-1, 1; length = 20)
```

The `range` function has a short-hand syntax, `start:step:stop`:

```{.julia}
julia> 0.0:2.5:10.0
0.0:2.5:10.0

julia> collect(0.0:2.5:10.0)
5-element Vector{Float64}:
  0.0
  2.5
  5.0
  7.5
 10.0

julia> 0.0:2.5:10.0 == range(0, 10; step = 2.5)
true
```

## Calculating and visualizing function values over a sequence

::: {.callout-tip title="`map`: to apply a function to every element in a collection" .column-margin}

The `map` function applies a given function to every element of a collection, returning a new collection of the results. `map(x -> 6x + 4, x_values)` passes each value in `x_values` through the function (here an *anonymous function*, defined using the *arrow function definition syntax*, `x -> 6x + 4`), one at a time, producing a corresponding output value for each. This is a common and idiomatic pattern in Julia: rather than writing an explicit loop, you *map* a transformation over a collection. The result has the same length and order as the input.

:::


::: {.callout-tip title="Anonymous vs. named functions" .column-margin}

Note that here we passed `map` an *anonymous function*.

An *anonymous function* is a function defined without a name, typically for immediate or one-time use, using the arrow syntax, which list the input arguments of the left of the `->` and output on the right.
For example,`x -> x^2` is an anonymous function that squares its input, while `(n_apples, price_of_apple) -> n_apples * price_of_apple` calculates the price of a collection of apples.

Anonymous functions are most commonly used when a function is simple and only needed in one place, defining it anonymously is cleaner than giving it a name.
Typically, as functions get more complex, or for documentation and replicability reasons, we often prefer to use named functions.
```julia

model1(x) = 6x + 4

function model2(x) 
  x^2 + 2x + 3
end

map(model1, x_values)
map(model2, x_values)
```


:::

We calculate the $y$ values corresponding to each $x$ value generated by the `range` object using the `map` function, and visualize the relationship between the $x$ and $y$ points using the `scatter` function from the `CairoMakie` library:


```{julia}
using CairoMakie
x_values = -10:0.01:10
y_values = map(x -> 6x + 4, x_values)
scatter(x_values, y_values)
```

or, if we do not need to store the $y$ values beyond the visualization:

```{.julia}
using CairoMakie
X = -10:0.01:10
scatter(X, map(x -> 6x + 4, X))
```

---

::: {.curriculum-exercise}

Visualize larger ranges and higher resolutions (smaller steps) of $x$-values of this same model 

$$
y = 6x + 4
$$

to see if the relationships change:

- $-1000 < x < 1000$, with step sizes of 1.0
- $0 < x < 1.0$, with step sizes of 0.001 

:::

---

::: {.curriculum-exercise}

Visualize the following models in terms of the relationship between the varibles under the specified ranges:

1. $f(x) = \frac{1}{x}, x \in \{1, 2, \ldots, 100\}$
1. $f(x) = x^2, -10 \le x \le 10$

:::

