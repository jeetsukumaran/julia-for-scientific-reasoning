[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "content/01_practicals/02_basics-of-visualizing-mathematical-models/index.html",
    "href": "content/01_practicals/02_basics-of-visualizing-mathematical-models/index.html",
    "title": "Generating sequences of values using the range function",
    "section": "",
    "text": "This is an example of a mathematical model relating \\(y\\) values to \\(x\\):\nTo visualize this in Julia, we generate sets \\(x\\) and \\(y\\) values conforming to the above relationship and pass these to the plotting function. These values may be generated systematically—a sequence generated by an algorithm—or stochastically—sampled from a probabilistic distribution. Here, we will discuss the first case.\nIn all cases, we have to ensure that the type and range of values conform to the assumptions of the model. In this example, The \\(x\\) and \\(y\\) values will be assumed to be, each, single-dimensional real values, \\(x, y \\in \\mathrm{R}^1\\), taking values in the entire real line. The \\(y\\) values here are deterministic functions of the \\(x\\) values, and so they can be calculated from the \\(x\\) values, once these have been generated.",
    "crumbs": [
      "Practicals",
      "Generating sequences of values using the `range` function"
    ]
  },
  {
    "objectID": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-03_basics-of-figures.html",
    "href": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-03_basics-of-figures.html",
    "title": "Plotting containers: Figure and Axis objects",
    "section": "",
    "text": "Proficiencies\n\nFor pilot and exploratory work: plotting without explicit Figure and Axis objects.\nCreating a Figure container object to hold all the plots.\nCreating an Axis object onto which you will do the plotting, and placing it in a Figure object.\nUsing a stock plotting functions to plot given 2-dimensional data (\\(x-\\) and \\(y\\)-coordinates, for example).\nSaving the figure to a file or displaying it in-situ.",
    "crumbs": [
      "Practicals",
      "Basics of visualizing mathematical models",
      "Plotting containers: `Figure` and `Axis` objects"
    ]
  },
  {
    "objectID": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-03_basics-of-figures.html#plotting-with-implict-axis-and-figure",
    "href": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-03_basics-of-figures.html#plotting-with-implict-axis-and-figure",
    "title": "Plotting containers: Figure and Axis objects",
    "section": "1 Plotting with implict Axis and Figure",
    "text": "1 Plotting with implict Axis and Figure\n\n\n# Load the graphical module\nusing CairoMakie\n\n# Generate x-values from 1 to 100\nx_vals = 1:100\n\n# Generate y-values from function applied to x-values\ny_vals = map(x -&gt; 3x + 2, x_vals)\n\n# Plot (and display) using the `scatter` function\nrender = scatter(x_vals, y_vals)\n\n# Save to file\n# save(\"scatter1.pdf\", render)\n# Show figure in the REPL\n# render.figure",
    "crumbs": [
      "Practicals",
      "Basics of visualizing mathematical models",
      "Plotting containers: `Figure` and `Axis` objects"
    ]
  },
  {
    "objectID": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-03_basics-of-figures.html#plotting-with-explicit-axis-and-figure-management",
    "href": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-03_basics-of-figures.html#plotting-with-explicit-axis-and-figure-management",
    "title": "Plotting containers: Figure and Axis objects",
    "section": "2 Plotting with explicit Axis and Figure management",
    "text": "2 Plotting with explicit Axis and Figure management\n\n# Load the graphical module\nusing CairoMakie\n\n# Create a `Figure` object\nfigure = Figure();\n\n# Create an `Axis` object, placing it in the center of the figure.\n# `[1, 1]` specifies cell (1, 1) of a grid that grows dynamically as \n# cells are specified. Here, as there is only one cell defined, it\n# effectively places the `Axis` object in the center of the `Figure`\n# object\nax = Axis(figure[1, 1])\n\n# Plot some data onto the Axis object\n\n# x-coordinate values: a sequence from 0.0 to 100.0, in 0.01 step increments\nx_vals = 0:0.1:100.0\n\n# y-coordinate values: a function of the x-coordinate values\n#\n# $$\n# y = 4 x^2 + 2 x + 3\n# $$\n#\ny_vals = map(x -&gt; 4(x^2) + 2x + 3, x_vals)\n\n# Plot using the `scatter!` function\n# Note: the name is `scatter!` not `scatter`, and we pass \n# in the Axis object `ax` as the first argument\nscatter!(ax, x_vals, y_vals)\n\n# Save to file\n# save(\"scatter1.pdf\", render)\n# Show figure in the REPL\n# render.figure\n\nScatter{Tuple{Vector{Point{2, Float64}}}}",
    "crumbs": [
      "Practicals",
      "Basics of visualizing mathematical models",
      "Plotting containers: `Figure` and `Axis` objects"
    ]
  },
  {
    "objectID": "content/01_practicals/01_orientation-and-tooling/01-02_shell-file-system-essentials.html",
    "href": "content/01_practicals/01_orientation-and-tooling/01-02_shell-file-system-essentials.html",
    "title": "Shell and file-system essentials",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "Practicals",
      "Introduction, orientation, and tooling",
      "Shell and file-system essentials"
    ]
  },
  {
    "objectID": "content/01_practicals/01_orientation-and-tooling/index.html",
    "href": "content/01_practicals/01_orientation-and-tooling/index.html",
    "title": "Introduction, orientation, and tooling",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "Practicals",
      "Introduction, orientation, and tooling"
    ]
  },
  {
    "objectID": "content/01_practicals/01_orientation-and-tooling/01-01_introduction-to-the-computing-ecosystem.html",
    "href": "content/01_practicals/01_orientation-and-tooling/01-01_introduction-to-the-computing-ecosystem.html",
    "title": "Introduction to the computing ecosystem",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "Practicals",
      "Introduction, orientation, and tooling",
      "Introduction to the computing ecosystem"
    ]
  },
  {
    "objectID": "content/01_practicals/03_basics-of-working-with-stochastic-processes-and-distributions/index.html",
    "href": "content/01_practicals/03_basics-of-working-with-stochastic-processes-and-distributions/index.html",
    "title": "Random number generation",
    "section": "",
    "text": "Proficiencies",
    "crumbs": [
      "Practicals",
      "Random number generation"
    ]
  },
  {
    "objectID": "content/02_primers/index.html",
    "href": "content/02_primers/index.html",
    "title": "Primers",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\nPracticals: visualization\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Primers"
    ]
  },
  {
    "objectID": "content/02_primers/frank1996model_single-strain-parasite-fitness.html",
    "href": "content/02_primers/frank1996model_single-strain-parasite-fitness.html",
    "title": "Pathogen fitness as a function of virulence (Frank, 1996)",
    "section": "",
    "text": "(Frank 1996) provides an alternate formulation of virulence-transmission trade-off which defines pathogen fitness as a product of increase in capacity for transmission success for a particular pathogen reproductive intensity, weighted or scaled by the reduction in opportunity, duration, or effectiveness in transmission due to damage to the host due to the virulence of that reproductive intensity.\nThe fitness of a pathogen can be measured by the net gain in infected hosts, \\(w\\),\n\\[\nw = z f(z),\n\\tag{1}\\]\nwhere:\n\n\\(w\\) is the pathogen fitness (corresponding to \\(R_0\\), the net total reproductive output of the virus in terms of newly infected hosts),\n\\(z\\) is a measure correlated positively with parasite reproductive intensity, which correlates positively with capacity for transmission success, as measured by the number of hosts infected by a single infected host given full transmission opportunity (if host fitness, longevity, resources, mobility, etc. were not impacted by virus reproductive activity),\n\\(f(z)\\), a “declining function of \\(z\\)” (meaning that \\(f(z)\\) decreases as \\(z\\) increases), which is the cost or penalty factor accounting for reduction in transmission success due to depletion of host resources, fitness, longevity and so on as a result of pa.",
    "crumbs": [
      "Primers",
      "Pathogen fitness as a function of virulence (Frank, 1996)"
    ]
  },
  {
    "objectID": "content/02_primers/frank1996model_single-strain-parasite-fitness.html#pathogen-fitness-as-function-of-virulence",
    "href": "content/02_primers/frank1996model_single-strain-parasite-fitness.html#pathogen-fitness-as-function-of-virulence",
    "title": "Pathogen fitness as a function of virulence (Frank, 1996)",
    "section": "",
    "text": "(Frank 1996) provides an alternate formulation of virulence-transmission trade-off which defines pathogen fitness as a product of increase in capacity for transmission success for a particular pathogen reproductive intensity, weighted or scaled by the reduction in opportunity, duration, or effectiveness in transmission due to damage to the host due to the virulence of that reproductive intensity.\nThe fitness of a pathogen can be measured by the net gain in infected hosts, \\(w\\),\n\\[\nw = z f(z),\n\\tag{1}\\]\nwhere:\n\n\\(w\\) is the pathogen fitness (corresponding to \\(R_0\\), the net total reproductive output of the virus in terms of newly infected hosts),\n\\(z\\) is a measure correlated positively with parasite reproductive intensity, which correlates positively with capacity for transmission success, as measured by the number of hosts infected by a single infected host given full transmission opportunity (if host fitness, longevity, resources, mobility, etc. were not impacted by virus reproductive activity),\n\\(f(z)\\), a “declining function of \\(z\\)” (meaning that \\(f(z)\\) decreases as \\(z\\) increases), which is the cost or penalty factor accounting for reduction in transmission success due to depletion of host resources, fitness, longevity and so on as a result of pa.",
    "crumbs": [
      "Primers",
      "Pathogen fitness as a function of virulence (Frank, 1996)"
    ]
  },
  {
    "objectID": "content/02_primers/frank1996model_single-strain-parasite-fitness.html#linear-decline-in-host-resources-due-to-virulence",
    "href": "content/02_primers/frank1996model_single-strain-parasite-fitness.html#linear-decline-in-host-resources-due-to-virulence",
    "title": "Pathogen fitness as a function of virulence (Frank, 1996)",
    "section": "2 Linear decline in host resources due to virulence",
    "text": "2 Linear decline in host resources due to virulence\n(Frank 1996) describes a linear function to model the degradation of the host resources available due to virulence, \\(f(z) = 1 - \\alpha z\\), where \\(\\alpha\\) is a scaling relation between transmission (\\(z\\)) and virulence (\\(\\alpha z\\)).\nThe pathogen fitness function under this linear scaling is\n\\[\n\\begin{align}\nw = z (1 - \\alpha z)\n\\end{align}\n\\tag{2}\\]",
    "crumbs": [
      "Primers",
      "Pathogen fitness as a function of virulence (Frank, 1996)"
    ]
  },
  {
    "objectID": "content/02_primers/pseudo-random-number-generators_01.html",
    "href": "content/02_primers/pseudo-random-number-generators_01.html",
    "title": "Pseudo-random number generators",
    "section": "",
    "text": "Key concept: Pseudo-random number generators use finite internal state and seeded algorithms to produce reproducible sequences that statistically approximate random behavior for practical and scientific use.\n\nA computer algorithm cannot generate a truly random result. Computer algorithms are deterministic. However, a computer algorithm can generate a sequence of numbers based on a series of deterministic calculations that behave like a sequence of random numbers would under statistical analysis. These algorithms are known as pseudo-random number generators (PRNGs). Pseudo-random number generators are deterministic, and, being deterministic, their results — the sequence of numbers they generate — are completely determined by the algorithm and the initial seed.\nA computer program (or algorithm) is a deterministic machine. For some given input, it produces a particular output, based on its programming. It cannot produce a truly random value in the sense of being fundamentally unpredictable from its inputs, as, for any particular input, an algorithm will produce the same output. For many applications, however, what is needed are not values that are absolutely random, but rather a series of numbers that behave as though they are random with respect to each other, at least up to some scale — values that can be generated one after another that do not exhibit detectable periodicities, patterns, ordering, or structure in the sequence, at least for the scale or size relevant to the application. (For applications where true physical unpredictability is strictly required, computers rely on hardware incorporating some physical source of randomness, such as radioactive decay or other entropy-harvesting mechanisms.)\nA pseudo-random number generator is a computer algorithm that can produce a series of values that behave like a random sequence with no detectable periodicity or pattern, statistically or otherwise, for a very long run of numbers. (The number of values a particular PRNG can generate before repeating is known as its period. All PRNGs have finite periods, i.e. will eventually begin repeating the sequence, but good PRNGs, and the ones we will be using, have HUGE periods (\\(2^{128}\\), for example). All PRNGs have finite periods because they must operate with a finite internal state represented with a finite number of bits. The number of bits used to represent the internal state that the PRNG tracks sets the upper bound on the number of distinct states the generator can occupy. This also sets an upper bound on the length of the sequence before repetition must occur. At some point, the update step will produce a state value that has been used before in the sequence, resulting in the sequence repeating from that point. A 32-bit state PRNG might repeat after at most \\(2^{32}\\) steps, while cryptographic applications (and many modern computing platforms, including Julia) use 128-bit or larger states, resulting in periods on the order of \\(2^{128}\\) or larger.)\nThe sequence of numbers generated by a PRNG behaves as though it were random in most practical statistical senses, including measures such as empirical entropy or goodness-of-fit to a uniform probability distribution, except for one crucial feature: the sequence is completely determined by the algorithm and the seed. For most non-cryptographic applications, this determinism is not a limitation. What matters is that there is no detectable ordering, patterns, autocorrelations, cross-correlations, or other structure in the numbers at the scale relevant to the application, and that the empirical frequency distribution of values approximates that of a uniform probability distribution. This a well-designed PRNG can deliver, provided usage does not exceed its intended operational limits. (While the entire sequence of numbers generated by a PRNG is determined by the algorithm and initial seed, predicting future outputs without knowledge of the internal state or transition function may be computationally infeasible in the case of cryptographically secure generators, though it is often feasible for simpler non-cryptographic PRNGs.)\nGiven an initial starting or “seed” value, a PRNG algorithm computes and returns a value, and then updates an internal state that is used to generate the next value, thus forming a chain of state updates and outputs. In more complex algorithms, a separate internal state consisting of multiple values is updated from the previous state, and a separate function is used to calculate the output from this internal state. It is this internal state that is passed to the next step rather than the output value itself. In this way, with each state update deterministically producing the next, a sequence of numbers is generated from the initial seed. The entire sequence is therefore completely determined by the seed value. Any particular seed value given to the algorithm, e.g., 108 or 99, will always return the exact same sequence of numbers. While not truly random in a physical sense, the sequence behaves as random in that there are no detectable autocorrelations, patterns, or short-period repetitions at the scale for which the generator is designed.\nThis determinism of the number sequence from a pseudo-random number generator is not a practical limitation in most scientific computing contexts, and, in fact, has important roles in software engineering as well as research. It can be critically useful in software development: the key to solving a bug is to be able to reliably replicate it, and the reproducibility of a pseudo-random number sequence allows for debugging of programs that rely on randomness, including scientific software (e.g. Bayesian Markov chain Monte Carlo inference programs). It can also be very useful in scientific research: often it is sufficient to record the random seed used for a particular suite of simulations or stochastic heuristic-based inference for replicability purposes, instead of storing the giga-, tera-, or peta-bytes of data generated downstream from the random number sequence itself.\n\n\n\n Back to top",
    "crumbs": [
      "Primers",
      "Pseudo-random number generators"
    ]
  },
  {
    "objectID": "content/02_primers/pseudo-random-number-generators_03_details.html",
    "href": "content/02_primers/pseudo-random-number-generators_03_details.html",
    "title": "Pseudo-random number generators: continuous values from discrete machines",
    "section": "",
    "text": "A computer’s RNG (Random Number Generator), generates (pseudo-)random integer values. For continous value, the computer will generate values by sampling from a grid in \\([0, 1)\\).\nAs with the challenges of a deterministic machine generating random values, when requiring random continuous value, we are faced with the challenge of a discrete-value calculating machine dealing with non-integer values. A computer can generate a pseudo-random integer value, \\(k\\), using its Pseudo-Random Number Generator. For continuous values, the generated integer value, \\(k\\) is then scaled to a floating-point \\(x\\) by, for e.g., \\(\\frac{k}{2p}\\), where \\(p\\) is the number usable bits and \\(0 \\le k \\le 2^p - 1\\). The result in floating point value in the range \\(0 \\le x &lt; 1\\).\nWhile 1 is excluded from the range, this does not change the distribution. A continuous uniform distribution on \\([0, 1]\\) assigns probability zero to any single point, include \\(0\\) or \\(1\\) in that range, so this exclusion of 1 does not change the characteristics of the distribution. (With continuous distributions, we do not ask what is the probability of observing any particular value. We ask is the probability of observing a range of values.)\nLet\n\n\\(p\\) = number of mantissa bits of the target floating-point type (\\(p=53\\) for Float64)\n\\(k\\) drawn uniformly from\n\n\\[\n{0,1,\\dots,2^p - 1}\n\\]\nDefine\n\\[\nx = \\frac{k}{2^p}.\n\\]\nThen:\n\nThe mapping \\(k \\mapsto x\\) is bijective\nEach possible \\(x\\) has probability exactly \\(2^{-p}\\)\nThe support is\n\n\\[\n\\left\\{ 0, \\frac{1}{2^p}, \\frac{2}{2^p}, \\dots, \\frac{2^p-1}{2^p} \\right\\}\n\\subset [0,1)\n\\]\nNote this is a discrete uniform distribution over the set of values \\(\\{0, \\frac{1}{2^p}, \\frac{2}{2^p}, \\ldots, \\frac{2^p-1}{2^p}\\}\\), not a continuous one. The operation bins the range \\([0, 1)\\) into \\(2^p\\) equal width bins of \\(\\frac{1}{1^p}\\) width. For Float64 this result in \\(2^{53} \\approx 9 \\times 10^{15}\\) bins of width \\(2^{-53} \\approx 1.11 \\times 10^{-16}\\).",
    "crumbs": [
      "Primers",
      "Pseudo-random number generators: continuous values from discrete machines"
    ]
  },
  {
    "objectID": "content/02_primers/pseudo-random-number-generators_03_details.html#how-a-discrete-valued-machine-generating-continuous-random-values",
    "href": "content/02_primers/pseudo-random-number-generators_03_details.html#how-a-discrete-valued-machine-generating-continuous-random-values",
    "title": "Pseudo-random number generators: continuous values from discrete machines",
    "section": "",
    "text": "A computer’s RNG (Random Number Generator), generates (pseudo-)random integer values. For continous value, the computer will generate values by sampling from a grid in \\([0, 1)\\).\nAs with the challenges of a deterministic machine generating random values, when requiring random continuous value, we are faced with the challenge of a discrete-value calculating machine dealing with non-integer values. A computer can generate a pseudo-random integer value, \\(k\\), using its Pseudo-Random Number Generator. For continuous values, the generated integer value, \\(k\\) is then scaled to a floating-point \\(x\\) by, for e.g., \\(\\frac{k}{2p}\\), where \\(p\\) is the number usable bits and \\(0 \\le k \\le 2^p - 1\\). The result in floating point value in the range \\(0 \\le x &lt; 1\\).\nWhile 1 is excluded from the range, this does not change the distribution. A continuous uniform distribution on \\([0, 1]\\) assigns probability zero to any single point, include \\(0\\) or \\(1\\) in that range, so this exclusion of 1 does not change the characteristics of the distribution. (With continuous distributions, we do not ask what is the probability of observing any particular value. We ask is the probability of observing a range of values.)\nLet\n\n\\(p\\) = number of mantissa bits of the target floating-point type (\\(p=53\\) for Float64)\n\\(k\\) drawn uniformly from\n\n\\[\n{0,1,\\dots,2^p - 1}\n\\]\nDefine\n\\[\nx = \\frac{k}{2^p}.\n\\]\nThen:\n\nThe mapping \\(k \\mapsto x\\) is bijective\nEach possible \\(x\\) has probability exactly \\(2^{-p}\\)\nThe support is\n\n\\[\n\\left\\{ 0, \\frac{1}{2^p}, \\frac{2}{2^p}, \\dots, \\frac{2^p-1}{2^p} \\right\\}\n\\subset [0,1)\n\\]\nNote this is a discrete uniform distribution over the set of values \\(\\{0, \\frac{1}{2^p}, \\frac{2}{2^p}, \\ldots, \\frac{2^p-1}{2^p}\\}\\), not a continuous one. The operation bins the range \\([0, 1)\\) into \\(2^p\\) equal width bins of \\(\\frac{1}{1^p}\\) width. For Float64 this result in \\(2^{53} \\approx 9 \\times 10^{15}\\) bins of width \\(2^{-53} \\approx 1.11 \\times 10^{-16}\\).",
    "crumbs": [
      "Primers",
      "Pseudo-random number generators: continuous values from discrete machines"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "content/02_primers/frank1996model_virulence-transmission-tradeoff.html",
    "href": "content/02_primers/frank1996model_virulence-transmission-tradeoff.html",
    "title": "Virulence-transmission trade-off (Frank, 1996)",
    "section": "",
    "text": "The classical virulence-transmission trade-off function, following the notation of (Frank 1996), is:\n\\[\nR_0 = \\frac{\\beta(\\nu)N}{\\delta + \\nu + c(\\nu)},\n\\]\nwhere:\n\n\\(R_0\\) The basic reproduction number. The expected number of secondary infections produced by a single infected host introduced into a fully susceptible population of size \\(N\\). The transmission intensity multiplied by mean infectious duration.\n\\(\\nu\\) Virulence. In this formulation, \\(\\nu\\) is the disease-induced host mortality intensity. This represents the per-capita hazard at which infected hosts die because of the pathogen.\n\\(\\beta(\\nu)\\) Transmission coefficient (often called the transmission intensity). It gives the per-capita rate at which an infected host generates new infections per susceptible host, and it is assumed to depend on virulence. The biological trade-off is encoded here: increasing \\(\\nu\\) may increase within-host replication and hence transmission, so \\(\\beta'(\\nu) &gt; 0\\) over some range.\n\\(N\\) Total density (or number) of susceptible hosts in the population at invasion. Because \\(R_0\\) is defined at the start of an epidemic, essentially all hosts are susceptible, so the force of infection scales with \\(N\\).\n\\(\\delta\\) Background host mortality intensity (natural death intensity unrelated to infection). This removes infected hosts independently of the pathogen’s virulence.\n\\(c(\\nu)\\) Additional loss intensity associated with infection that is not direct mortality. Examples include recovery with immunity, behavioral isolation, treatment, or reduced contact rate induced by symptoms. It may depend on virulence if, for example, more virulent infections provoke faster immune clearance or stronger behavioral avoidance.\n\n\n\n\n\n\n\n\nTipIntensity vs. rate\n\n\n\nAll intensities are rates, but not all rates are intensities. A rate is a general term indicating the change of one quantity relative to another, expresed as a ratio (“rate” and “ratio” have the same linguistic root). An “intensity” is a rate, but one some characteristics is the instantaneous hazard parameter (= rate) of a stochastic process. In classical ODE epidemic models (e.g., SIR), “rate” and “intensity” are often used interchangeably because constant hazards produce exponential waiting times and yield linear per-capita ODE terms.\n\nNote that:\n\\[\nR_0 = \\text{transmission intensity} \\times \\text{mean infection duration}.\n\\]\n\nThe numerator, \\(\\beta(\\nu)N\\), is the transmission intensity, i.e. the per-capita intensity (or rate) of generating new infections in a population of size \\(N\\).\nThe denominator \\(\\delta + \\nu + c(\\nu)\\) gives the total removal intensity of infected hosts: the rate of removal of infected hosts from the population. Thus, \\(\\frac{1}{\\delta + \\nu + c(\\nu)}\\) gives the mean infectious duration.\n\nAs \\(R_0\\) measures the net increase of infected host over time, expressed as a ratio of infected hosts gain (the numerator) to infected hosts lost (the denominator), it serves as an index of the epidemiological state of an infectious disease. - If the numerator is greater than the denominator, there will be more infections generated than removed from the population, leading to a net increase in infections: the disease in an epidemic phase. - If the numerator is less than the denominator, there infections will be removed from the population faster than new infections will occur: the disease will “die out” without becoming an epidemic.\n\n\n\n\n Back to topReferences\n\nFrank, Steven A. 1996. “Models of Parasite Virulence.” The Quarterly Review of Biology 71 (1): 37–78. https://doi.org/10.1086/419267.",
    "crumbs": [
      "Primers",
      "Virulence-transmission trade-off (Frank, 1996)"
    ]
  },
  {
    "objectID": "content/02_primers/pseudo-random-number-generators_02_best-practices.html",
    "href": "content/02_primers/pseudo-random-number-generators_02_best-practices.html",
    "title": "Pseudo-random number generators: best practices",
    "section": "",
    "text": "In development, exploratary, pilot, or less demanding workflows you can rely on the default random generator, using the Random.seed! function to set the seed.\nusing Random\n\n# Get reference to the global random number generator\nrng = Random.default_rng()\n# Explicitly set its seed\nRandom.seed!(rng, 42)\n\n#  \nrand(Int, 10)\nrand(['A', 'C', 'G', 'T'])",
    "crumbs": [
      "Primers",
      "Pseudo-random number generators: best practices"
    ]
  },
  {
    "objectID": "content/02_primers/pseudo-random-number-generators_02_best-practices.html#use-the-default-random-number-generator-for-convenience",
    "href": "content/02_primers/pseudo-random-number-generators_02_best-practices.html#use-the-default-random-number-generator-for-convenience",
    "title": "Pseudo-random number generators: best practices",
    "section": "",
    "text": "In development, exploratary, pilot, or less demanding workflows you can rely on the default random generator, using the Random.seed! function to set the seed.\nusing Random\n\n# Get reference to the global random number generator\nrng = Random.default_rng()\n# Explicitly set its seed\nRandom.seed!(rng, 42)\n\n#  \nrand(Int, 10)\nrand(['A', 'C', 'G', 'T'])",
    "crumbs": [
      "Primers",
      "Pseudo-random number generators: best practices"
    ]
  },
  {
    "objectID": "content/02_primers/pseudo-random-number-generators_02_best-practices.html#explicitly-manage-the-random-number-generator-for-robust-reproducibility-and-replicability",
    "href": "content/02_primers/pseudo-random-number-generators_02_best-practices.html#explicitly-manage-the-random-number-generator-for-robust-reproducibility-and-replicability",
    "title": "Pseudo-random number generators: best practices",
    "section": "2 Explicitly manage the random number generator for robust reproducibility and replicability",
    "text": "2 Explicitly manage the random number generator for robust reproducibility and replicability\nIn the full and final production-grade software, you should design all your programs to (1) optionally take a user-specific random number seed and, if not given, generate your own; (2) report and log the random number seed used; and (3) instantiate and use your own random number generator object in all computation, passing it around to different functions or objects that need them.\nusing Random\n\n# Instantiate a PRNG using the \"Xoshiro\" algorithm with the seed value of 42\nrng = Random.Xoshiro(42)\n# Instantiate a PRNG using the \"Mersenne Twister\" with the seed value of 1999\nrng = Random.MersenneTwister(1999)\n\n# Use `rand` with the `rng` to sample an `Int` (integer) value\nrand(rng, Int, 10)\n# Use `rand` with the `rng` to sample a random value from the list\nrand(rng, ['A', 'C', 'G', 'T'])",
    "crumbs": [
      "Primers",
      "Pseudo-random number generators: best practices"
    ]
  },
  {
    "objectID": "content/02_primers/markov-property.html",
    "href": "content/02_primers/markov-property.html",
    "title": "Markov property",
    "section": "",
    "text": "A stochastic process \\((X_t)_{t \\ge 0}\\) has the Markov property if \\[\n\\Pr(X_{t+1} = j \\mid X_t = i, X_{t-1}, \\dots)\n=\n\\Pr(X_{t+1} = j \\mid X_t = i).\n\\]",
    "crumbs": [
      "Primers",
      "Markov property"
    ]
  },
  {
    "objectID": "content/02_primers/markov-property.html#sec-markov-property",
    "href": "content/02_primers/markov-property.html#sec-markov-property",
    "title": "Markov property",
    "section": "",
    "text": "A stochastic process \\((X_t)_{t \\ge 0}\\) has the Markov property if \\[\n\\Pr(X_{t+1} = j \\mid X_t = i, X_{t-1}, \\dots)\n=\n\\Pr(X_{t+1} = j \\mid X_t = i).\n\\]",
    "crumbs": [
      "Primers",
      "Markov property"
    ]
  },
  {
    "objectID": "content/01_practicals/03_basics-of-working-with-stochastic-processes-and-distributions/03-01_basics-of-random-number-generation.html",
    "href": "content/01_practicals/03_basics-of-working-with-stochastic-processes-and-distributions/03-01_basics-of-random-number-generation.html",
    "title": "Random number generation",
    "section": "",
    "text": "Proficiencies",
    "crumbs": [
      "Practicals",
      "Basics of working with randomness and probabilities",
      "Random number generation"
    ]
  },
  {
    "objectID": "content/01_practicals/03_basics-of-working-with-stochastic-processes-and-distributions/03-01_basics-of-random-number-generation.html#the-rand-function",
    "href": "content/01_practicals/03_basics-of-working-with-stochastic-processes-and-distributions/03-01_basics-of-random-number-generation.html#the-rand-function",
    "title": "Random number generation",
    "section": "1 The rand function",
    "text": "1 The rand function\nThe rand function is the function we will most often use to generate random variates of different shapes, and sizes and characteristics. The rand function has a number of different methods for generating random values of various different data types, structures, and ranges. The core Julia provides a collection rand methods that generate values sampled from uniform distributions, (and a parallel collection of methods for sampling from the normal distribution, randn). Packages such as Distributions.jl provide the ability to generate random values sampled from a broader range of distributions.\n\n\n\n\n\n\n\nTipFunctions vs methods in Julia\n\n\n\nIn Julia, a function is a operation that can accept inputs and returns a value. A method is a specific implementation of that function for particular input types or argument combinations. When you call rand(), rand(Int), or rand(1:6), you are calling different methods of the same function. Julia automatically selects the appropriate method based on the types and number of arguments you provide, as long as someone (the Julia programmers, package programmers, or yourself) has written a function that takes combination of arguments, a mechanism called multiple dispatch.",
    "crumbs": [
      "Practicals",
      "Basics of working with randomness and probabilities",
      "Random number generation"
    ]
  },
  {
    "objectID": "content/01_practicals/03_basics-of-working-with-stochastic-processes-and-distributions/03-01_basics-of-random-number-generation.html#methods-of-the-rand-function",
    "href": "content/01_practicals/03_basics-of-working-with-stochastic-processes-and-distributions/03-01_basics-of-random-number-generation.html#methods-of-the-rand-function",
    "title": "Random number generation",
    "section": "2 Methods of the rand function",
    "text": "2 Methods of the rand function\n\n2.1 Sampling a uniform random value of a particular type\n\njulia&gt; rand(Int) # Generate a random integer\n-6581752414023885448\n\njulia&gt; rand(Float64) # Generate a random (64-bit) floating point\n0.5551313236725943\n\njulia&gt; rand(Int, 10) # Generate 10 random integers\n10-element Vector{Int64}:\n  7698269277784285493\n   119518414081352549\n -7810994830346528650\n -2227295384308136057\n -3787444672257423100\n  2454496437854673843\n -4688583217568250768\n  3428356285250979074\n   217784465829442243\n -2477159631785889726\n\njulia&gt; rand(Float64, 10) # Generate 10 random (64-bit) floating point values\n10-element Vector{Float64}:\n 0.8121004451418985\n 0.7498281699504885\n 0.262689399562409\n 0.551763388172788\n 0.7264346095273245\n 0.8899981043981576\n 0.4991116861348205\n 0.8177168948063814\n 0.8108662080895137\n 0.14549261534858948\n\n\n2.2 Sampling from a defined range or collection with uniform random probability\n\nrand(-500:500, 4) # Sample 4 integer numbers between -500 and 500\n\nrand([0.1, 0.2, 0.3, 0.4], 2) # Sample 2 values from the array of floating points [0.1, 0.2, 0.3, 0.4]\n\nrand(['A', 'C', 'G', 'T'], 3) # Sample 3 values from the array of characters ['A', 'C', 'G', 'T']\n\n\n2.3 Sampling random continuous values from \\((0, 1]\\) with uniform probability",
    "crumbs": [
      "Practicals",
      "Basics of working with randomness and probabilities",
      "Random number generation"
    ]
  },
  {
    "objectID": "content/01_practicals/03_basics-of-working-with-stochastic-processes-and-distributions/03-01_basics-of-random-number-generation.html#sampling-a-random-event-of-a-particular-probaility",
    "href": "content/01_practicals/03_basics-of-working-with-stochastic-processes-and-distributions/03-01_basics-of-random-number-generation.html#sampling-a-random-event-of-a-particular-probaility",
    "title": "Random number generation",
    "section": "3 Sampling a random event of a particular probaility",
    "text": "3 Sampling a random event of a particular probaility",
    "crumbs": [
      "Practicals",
      "Basics of working with randomness and probabilities",
      "Random number generation"
    ]
  },
  {
    "objectID": "content/01_practicals/01_orientation-and-tooling/01-04_julia-runtime-programs-repl-files.html",
    "href": "content/01_practicals/01_orientation-and-tooling/01-04_julia-runtime-programs-repl-files.html",
    "title": "Working with Julia: runtime, REPL, files, and programs",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "Practicals",
      "Introduction, orientation, and tooling",
      "Working with Julia: runtime, REPL, files, and programs"
    ]
  },
  {
    "objectID": "content/01_practicals/01_orientation-and-tooling/01-03_installing-julia.html",
    "href": "content/01_practicals/01_orientation-and-tooling/01-03_installing-julia.html",
    "title": "Working with Julia: Installing Julia",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "Practicals",
      "Introduction, orientation, and tooling",
      "Working with Julia: Installing Julia"
    ]
  },
  {
    "objectID": "content/01_practicals/01_orientation-and-tooling/01-05_julia-environments-packages-and-projects.html",
    "href": "content/01_practicals/01_orientation-and-tooling/01-05_julia-environments-packages-and-projects.html",
    "title": "Working with Julia: environments, projects, packages, and package management",
    "section": "",
    "text": "Back to top",
    "crumbs": [
      "Practicals",
      "Introduction, orientation, and tooling",
      "Working with Julia: environments, projects, packages, and package management"
    ]
  },
  {
    "objectID": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-04_basics-of-visualizing-models_01_single-strain-virulence-evolution.html",
    "href": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-04_basics-of-visualizing-models_01_single-strain-virulence-evolution.html",
    "title": "Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "section": "",
    "text": "Proficiencies",
    "crumbs": [
      "Practicals",
      "Basics of visualizing mathematical models",
      "Visualizing the single-strain parasite virulence-transmission balance fitness landscape"
    ]
  },
  {
    "objectID": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-04_basics-of-visualizing-models_01_single-strain-virulence-evolution.html#parasite-fitness-function",
    "href": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-04_basics-of-visualizing-models_01_single-strain-virulence-evolution.html#parasite-fitness-function",
    "title": "Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "section": "1 Parasite fitness function",
    "text": "1 Parasite fitness function\n\nThe single-strain parasite fitness model is given as (Frank 1996):\nAs discussed in ?@sec-markov-property, the defining condition only depends on the present state.\n\\[\n\\begin{aligned}\nw = z (1 - \\alpha z)\n\\end{aligned}\n\\tag{1}\\]\nwhere:\n\n\\(w\\) is a measure of parasite fitness,\n\\(z\\) is a measure of the parasite host exploitation severity, correlating positively with parasite reproductive and host colonization capacity, and\n\\(\\alpha z\\) is a measure of virulence, the damage a parasite does to the host as a result of exploitation \\(z\\), with \\(\\alpha\\) a scaling factor, weighting the damage of the parasite reproductive activity in reducing the host resources available to the parasite.",
    "crumbs": [
      "Practicals",
      "Basics of visualizing mathematical models",
      "Visualizing the single-strain parasite virulence-transmission balance fitness landscape"
    ]
  },
  {
    "objectID": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-04_basics-of-visualizing-models_01_single-strain-virulence-evolution.html#behavior-under-adaptive-evolution",
    "href": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-04_basics-of-visualizing-models_01_single-strain-virulence-evolution.html#behavior-under-adaptive-evolution",
    "title": "Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "section": "2 Behavior under adaptive evolution",
    "text": "2 Behavior under adaptive evolution\nLet us consider host exploitation severity, \\(z\\), as a heritable trait that affects transmission success and virulence, and let \\(w(z, \\alpha)\\) be the fitness of of a parasite with host exploitation severity trait value \\(z\\), given some virulence impact weight \\(\\alpha\\).\nIf parasites vary in \\(z\\) and this variation is heritable, then strategies with larger \\(w(z)\\) tend to leave more descendants (i.e., spread more effectively).\nIn this simplified model, we therefore expect evolution to favor values of \\(z\\) that make \\(w(z)\\) as large as possible, so we look for the value of \\(z\\) that maximizes \\(w(z)\\).\nConceptually, we can treat \\(z\\) as a control or tuning variable: it is the parasite strategy we imagine changing. The parameter \\(\\alpha\\) determines how strongly exploitation reduces host resources (how costly virulence is per unit increase in \\(z\\)). For a fixed \\(\\alpha\\), plotting \\(w\\) against \\(z\\) shows a trade-off: increasing \\(z\\) raises transmission potential, but beyond a point the virulence cost dominates and \\(w\\) declines.",
    "crumbs": [
      "Practicals",
      "Basics of visualizing mathematical models",
      "Visualizing the single-strain parasite virulence-transmission balance fitness landscape"
    ]
  },
  {
    "objectID": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-04_basics-of-visualizing-models_01_single-strain-virulence-evolution.html#visualization-of-fitness-relationship-with-host-exploitation-severity",
    "href": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-04_basics-of-visualizing-models_01_single-strain-virulence-evolution.html#visualization-of-fitness-relationship-with-host-exploitation-severity",
    "title": "Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "section": "3 Visualization of fitness relationship with host exploitation severity",
    "text": "3 Visualization of fitness relationship with host exploitation severity\n\nProficiencies\n\nGenerating a 1D grid of input values with range (or start:step:stop).\nComputing model outputs over a grid with map.\nPlotting a single 2D relationship with an implicit figure/axis (quick exploratory plot).\nCreating an explicit Figure and Axis, and adding multiple curves to the same axis with ...! plotting functions.\nVisualizing a 2-parameter model as a surface by evaluating the model on a 2D grid.\n\n\n\nWe will visualize the single-strain fitness model\n\\[\nw(z;\\alpha) = z(1-\\alpha z),\n\\]\nwhere:\n\n\\(z\\) is host exploitation severity (the model’s adjustable trait variable),\n\\(\\alpha\\) is a fixed scaling parameter that determines how strongly exploitation reduces transmission opportunity,\n\\(w\\) is parasite fitness (new infected hosts per infected host under the model).\n\nIn Julia, we can generate a grid of \\(z\\) values, evaluate \\(w(z;\\alpha)\\), and plot \\(w\\) versus \\(z\\) for one or several choices of \\(\\alpha\\).\nWhen we plot \\(w\\) versus \\(z\\) for a fixed \\(\\alpha\\), we typically restrict to\n\\[\n0 \\le z \\le \\frac{1}{\\alpha},\n\\]\nso that the transmission-opportunity term \\((1-\\alpha z)\\) stays nonnegative.",
    "crumbs": [
      "Practicals",
      "Basics of visualizing mathematical models",
      "Visualizing the single-strain parasite virulence-transmission balance fitness landscape"
    ]
  },
  {
    "objectID": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-04_basics-of-visualizing-models_01_single-strain-virulence-evolution.html#single-alpha-implicit-plot-quick-exploratory",
    "href": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-04_basics-of-visualizing-models_01_single-strain-virulence-evolution.html#single-alpha-implicit-plot-quick-exploratory",
    "title": "Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "section": "4 Single \\(\\alpha\\), implicit plot (quick exploratory)",
    "text": "4 Single \\(\\alpha\\), implicit plot (quick exploratory)\n\nusing CairoMakie\n\n# Fitness model\nw(z, α) = z * (1 - α*z)\n\n# Choose a single α value\nα = 0.5\n\n# Generate z-values over the biologically meaningful range\nz_vals = range(0.0, 1/α; length = 400)\n\n# Evaluate the model on the grid\nw_vals = map(z -&gt; w(z, α), z_vals)\n\n# Quick plot with implicit Figure/Axis\nlines(z_vals, w_vals)\n\n\n\n\nThis produces one curve showing how fitness changes as host exploitation severity \\(z\\) increases, holding \\(\\alpha\\) fixed.\nMultiple \\(\\alpha\\) values on the same plot (explicit Figure and Axis) using CairoMakie\n\n# Fitness model\nw(z, α) = z * (1 - α*z)\n\n# Choose several α values to compare\nα_values = [0.2, 0.5, 1.0]\n\n# Create Figure and Axis explicitly\nfig = Figure()\nax = Axis(\n    fig[1, 1],\n    xlabel = \"host exploitation severity (z)\",\n    ylabel = \"parasite fitness (w)\",\n    title  = \"Fitness curves for different α\"\n)\n\n# Add one curve per α onto the same axis\nfor α in α_values\n    z_vals = range(0.0, 1/α; length = 400)\n    w_vals = map(z -&gt; w(z, α), z_vals)\n    lines!(ax, z_vals, w_vals, label = \"α = $(α)\")\nend\n\n# Add a legend\naxislegend(ax)\n\nfig\n\n\n\n\nHere, \\(\\alpha\\) plays the role of a parameter you “sweep” across several values, to see how the \\(w\\)–\\(z\\) relationship changes.\nSurface plot: fitness as a function of \\(z\\) and \\(\\alpha\\)\nTo visualize the full two-parameter relationship \\(w(z;\\alpha)\\), we evaluate \\(w\\) on a 2D grid of \\((z,\\alpha)\\) values and plot a surface.\n\nusing CairoMakie\n\n# Fitness model\nw(z, α) = z * (1 - α*z)\n\n# Grid of α values (parameter axis)\nα_vals = range(0.2, 1.0; length = 120)\n\n# Grid of z values (trait axis)\n# Use a common z-range for the surface; choose up to 1/max(α) so the full grid is comparable\nz_max = 1 / maximum(α_vals)\nz_vals = range(0.0, z_max; length = 200)\n\n# Evaluate w on the (z, α) grid:\n# W[i, j] = w(z_vals[i], α_vals[j])\nW = [w(z, α) for z in z_vals, α in α_vals]\n\n# Plot as a 3D surface\nfig = Figure()\nax3 = Axis3(\n    fig[1, 1],\n    xlabel = \"host exploitation severity (z)\",\n    ylabel = \"virulence scaling (α)\",\n    zlabel = \"parasite fitness (w)\",\n    title  = \"Fitness surface w(z; α)\"\n)\n\nsurface!(ax3, z_vals, α_vals, W)\n\nfig\n\n\n\n\nThis surface makes it visually explicit that \\(w\\) depends on both the trait value (\\(z\\)) and the environment/biology scaling parameter (\\(\\alpha\\)).\n\nExerciseSingle-curve practice (implicit plot)\nSet \\(\\alpha = 0.25\\) and reproduce the single-curve plot.\nIncrease the resolution by changing length = 400 to length = 2000.\nRestrict the plotted domain to \\(0 \\le z \\le \\frac{1}{2\\alpha}\\) and compare the shape to the full range \\(0 \\le z \\le \\frac{1}{\\alpha}\\).\n\n\n\nExerciseMultiple-curve practice (explicit Axis, adding curves)\nPlot curves for \\(\\alpha \\in {0.1, 0.2, 0.4, 0.8}\\) on the same axis.\nAdd a second axis below the first that plots the same curves using scatter! instead of lines!.\nChange axis labels and title so that the plot reads well when exported.\n\n\n\nExerciseSurface practice (2D grid evaluation)\nChange the \\(\\alpha\\) grid to range(0.1, 2.0; length = 200) and regenerate the surface.\nReplace the surface with a heatmap of \\(w\\) over \\((z,\\alpha)\\) using heatmap!(…).\nModify the grid so that, for each \\(\\alpha\\), you only include \\(z \\le 1/\\alpha\\) (the nonnegative-opportunity region) by setting \\(w(z,\\alpha) = NaN\\) whenever \\(z &gt; 1/\\alpha\\), and observe how the plotted region changes.",
    "crumbs": [
      "Practicals",
      "Basics of visualizing mathematical models",
      "Visualizing the single-strain parasite virulence-transmission balance fitness landscape"
    ]
  },
  {
    "objectID": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-02_generating-sequences-of-values-with-range-function.html",
    "href": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-02_generating-sequences-of-values-with-range-function.html",
    "title": "Generating sequences of values using the range function",
    "section": "",
    "text": "This is an example of a mathematical model relating \\(y\\) values to \\(x\\):\nTo visualize this in Julia, we generate sets \\(x\\) and \\(y\\) values conforming to the above relationship and pass these to the plotting function. These values may be generated systematically—a sequence generated by an algorithm—or stochastically—sampled from a probabilistic distribution. Here, we will discuss the first case.\nIn all cases, we have to ensure that the type and range of values conform to the assumptions of the model. In this example, The \\(x\\) and \\(y\\) values will be assumed to be, each, single-dimensional real values, \\(x, y \\in \\mathrm{R}^1\\), taking values in the entire real line. The \\(y\\) values here are deterministic functions of the \\(x\\) values, and so they can be calculated from the \\(x\\) values, once these have been generated.",
    "crumbs": [
      "Practicals",
      "Basics of visualizing mathematical models",
      "Generating sequences of values using the `range` function"
    ]
  },
  {
    "objectID": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-02_generating-sequences-of-values-with-range-function.html#generating-a-sequence-of-values-with-the-range-function",
    "href": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-02_generating-sequences-of-values-with-range-function.html#generating-a-sequence-of-values-with-the-range-function",
    "title": "Generating sequences of values using the range function",
    "section": "1 Generating a sequence of values with the range function",
    "text": "1 Generating a sequence of values with the range function\n\n\n\n\n\n\n\nNoteRange objects are algorithmic representation of ranges\n\n\n\nThe actual value returned by the range function are not actually arrays of values, but rather a special “lazy” range object, with “lazy” here being a program design term meaning that the resources (particularly memory) will be allocated only if and when needed. What this means is that you can construct very large collections of values, with large ranges and high resolution, but not pay the resource cost of holding all these values in memory at the same time.\njulia&gt; r = range(1e-10, 1e10; step = 0.001)\n1.0e-10:0.001:1.0e10\njulia&gt; length(r)\n10000000000001\njulia&gt; r[begin]\n1.0e-10\njulia&gt; r[end]\n1.0e10\njulia&gt; r[begin + 2]\n0.0020000001\njulia&gt; r[end - 4]\n9.999999999996e9\njulia&gt; r[1]\n1.0e-10\njulia&gt; r[2]\n0.0010000001\njulia&gt; r[3]\n0.0020000001\nTo actually generate the values, use the collect function, which will “unpack” the range object and return a Vector object (a single dimensional array) with the full sequence of values.\njulia&gt; r = range(0, 10; step = 2.5)\n0.0:2.5:10.0\n\njulia&gt; collect(r)\n5-element Vector{Float64}:\n 0.0\n 2.5\n 5.0\n 7.5\n10.0\n\nWe can generate a set of \\(x\\) values over a particular range of values, continuous or otherwise, using the range function in Julia. The range function has a number of different methods, but for our purposes we will focus on specifying the range in terms of a three parameters: a start value, a stop value, and either a step size (interval between consecutive values in the sequence),\njulia&gt; range(0, 10; step = 1)\n0:1:10\njulia&gt; range(0, 10; step = 0.2)\n0.0:0.2:10.0\njulia&gt; range(-10, 10; step = 2)\n-10:2:10\nor length (number of values) in the sequence,\njulia&gt; range(0, 10; length = 11)\n0.0:1.0:10.0\njulia&gt; range(0, 10; length = 5)\n0.0:2.5:10.0\njulia&gt; range(-1, 1; length = 20)\nThe range function has a short-hand syntax, start:step:stop:\njulia&gt; 0.0:2.5:10.0\n0.0:2.5:10.0\n\njulia&gt; collect(0.0:2.5:10.0)\n5-element Vector{Float64}:\n  0.0\n  2.5\n  5.0\n  7.5\n 10.0\n\njulia&gt; 0.0:2.5:10.0 == range(0, 10; step = 2.5)\ntrue",
    "crumbs": [
      "Practicals",
      "Basics of visualizing mathematical models",
      "Generating sequences of values using the `range` function"
    ]
  },
  {
    "objectID": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-02_generating-sequences-of-values-with-range-function.html#calculating-and-visualizing-function-values-over-a-sequence",
    "href": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-02_generating-sequences-of-values-with-range-function.html#calculating-and-visualizing-function-values-over-a-sequence",
    "title": "Generating sequences of values using the range function",
    "section": "2 Calculating and visualizing function values over a sequence",
    "text": "2 Calculating and visualizing function values over a sequence\nWe calculate the \\(y\\) values corresponding to each \\(x\\) value generated by the range object using the map function, and visualize the relationship between the \\(x\\) and \\(y\\) points using the scatter function from the CairoMakie library:\n\nusing CairoMakie\nx_values = -10:0.01:10\ny_values = map(x -&gt; 6x + 4, x_values)\nscatter(x_values, y_values)\n\n\n\n\nor, if we do not need to store the \\(y\\) values beyond the visualization:\nusing CairoMakie\nX = -10:0.01:10\nscatter(X, map(x -&gt; 6x + 4, X))\n\n\nExercise\nVisualize larger ranges and higher resolutions (smaller steps) of \\(x\\)-values of this same model\n\\[\ny = 6x + 4\n\\]\nto see if the relationships change:\n\n\\(-1000 &lt; x &lt; 1000\\), with step sizes of 1.0\n\\(0 &lt; x &lt; 1.0\\), with step sizes of 0.001\n\n\n\n\n\nExercise\nVisualize the following models in terms of the relationship between the varibles under the specified ranges:\n\n\\(f(x) = \\frac{1}{x}, x \\in \\{1, 2, \\ldots, 100\\}\\)\n\\(f(x) = x^2, -10 \\le x \\le 10\\)",
    "crumbs": [
      "Practicals",
      "Basics of visualizing mathematical models",
      "Generating sequences of values using the `range` function"
    ]
  },
  {
    "objectID": "content/01_practicals/index.html",
    "href": "content/01_practicals/index.html",
    "title": "Practicals",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\nModel: Single-lineage parasite virulence evolution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Practicals"
    ]
  },
  {
    "objectID": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-04_visualizing-single-strain-virulence-fitness.html",
    "href": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-04_visualizing-single-strain-virulence-fitness.html",
    "title": "Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "section": "",
    "text": "Proficiencies",
    "crumbs": [
      "Practicals",
      "Basics of visualizing mathematical models",
      "Visualizing the single-strain parasite virulence-transmission balance fitness landscape"
    ]
  },
  {
    "objectID": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-04_visualizing-single-strain-virulence-fitness.html#parasite-fitness-function",
    "href": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-04_visualizing-single-strain-virulence-fitness.html#parasite-fitness-function",
    "title": "Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "section": "1 Parasite fitness function",
    "text": "1 Parasite fitness function\n\nThe single-strain parasite fitness model is given as (Frank 1996):\nAs discussed in ?@sec-markov-property, the defining condition only depends on the present state.\n\\[\n\\begin{aligned}\nw = z (1 - \\alpha z)\n\\end{aligned}\n\\tag{1}\\]\nwhere:\n\n\\(w\\) is a measure of parasite fitness,\n\\(z\\) is a measure of the parasite host exploitation severity, correlating positively with parasite reproductive and host colonization capacity, and\n\\(\\alpha z\\) is a measure of virulence, the damage a parasite does to the host as a result of exploitation \\(z\\), with \\(\\alpha\\) a scaling factor, weighting the damage of the parasite reproductive activity in reducing the host resources available to the parasite.",
    "crumbs": [
      "Practicals",
      "Basics of visualizing mathematical models",
      "Visualizing the single-strain parasite virulence-transmission balance fitness landscape"
    ]
  },
  {
    "objectID": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-04_visualizing-single-strain-virulence-fitness.html#behavior-under-adaptive-evolution",
    "href": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-04_visualizing-single-strain-virulence-fitness.html#behavior-under-adaptive-evolution",
    "title": "Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "section": "2 Behavior under adaptive evolution",
    "text": "2 Behavior under adaptive evolution\nLet us consider host exploitation severity, \\(z\\), as a heritable trait that affects transmission success and virulence, and let \\(w(z, \\alpha)\\) be the fitness of of a parasite with host exploitation severity trait value \\(z\\), given some virulence impact weight \\(\\alpha\\).\nIf parasites vary in \\(z\\) and this variation is heritable, then strategies with larger \\(w(z)\\) tend to leave more descendants (i.e., spread more effectively).\nIn this simplified model, we therefore expect evolution to favor values of \\(z\\) that make \\(w(z)\\) as large as possible, so we look for the value of \\(z\\) that maximizes \\(w(z)\\).\nConceptually, we can treat \\(z\\) as a control or tuning variable: it is the parasite strategy we imagine changing. The parameter \\(\\alpha\\) determines how strongly exploitation reduces host resources (how costly virulence is per unit increase in \\(z\\)). For a fixed \\(\\alpha\\), plotting \\(w\\) against \\(z\\) shows a trade-off: increasing \\(z\\) raises transmission potential, but beyond a point the virulence cost dominates and \\(w\\) declines.",
    "crumbs": [
      "Practicals",
      "Basics of visualizing mathematical models",
      "Visualizing the single-strain parasite virulence-transmission balance fitness landscape"
    ]
  },
  {
    "objectID": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-04_visualizing-single-strain-virulence-fitness.html#visualization-of-fitness-relationship-with-host-exploitation-severity",
    "href": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-04_visualizing-single-strain-virulence-fitness.html#visualization-of-fitness-relationship-with-host-exploitation-severity",
    "title": "Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "section": "3 Visualization of fitness relationship with host exploitation severity",
    "text": "3 Visualization of fitness relationship with host exploitation severity\n\nProficiencies\n\nGenerating a 1D grid of input values with range (or start:step:stop).\nComputing model outputs over a grid with map.\nPlotting a single 2D relationship with an implicit figure/axis (quick exploratory plot).\nCreating an explicit Figure and Axis, and adding multiple curves to the same axis with ...! plotting functions.\nVisualizing a 2-parameter model as a surface by evaluating the model on a 2D grid.\n\n\n\nWe will visualize the single-strain fitness model\n\\[\nw(z;\\alpha) = z(1-\\alpha z),\n\\]\nwhere:\n\n\\(z\\) is host exploitation severity (the model’s adjustable trait variable),\n\\(\\alpha\\) is a fixed scaling parameter that determines how strongly exploitation reduces transmission opportunity,\n\\(w\\) is parasite fitness (new infected hosts per infected host under the model).\n\nIn Julia, we can generate a grid of \\(z\\) values, evaluate \\(w(z;\\alpha)\\), and plot \\(w\\) versus \\(z\\) for one or several choices of \\(\\alpha\\).\nWhen we plot \\(w\\) versus \\(z\\) for a fixed \\(\\alpha\\), we typically restrict to\n\\[\n0 \\le z \\le \\frac{1}{\\alpha},\n\\]\nso that the transmission-opportunity term \\((1-\\alpha z)\\) stays nonnegative.",
    "crumbs": [
      "Practicals",
      "Basics of visualizing mathematical models",
      "Visualizing the single-strain parasite virulence-transmission balance fitness landscape"
    ]
  },
  {
    "objectID": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-04_visualizing-single-strain-virulence-fitness.html#single-alpha-implicit-plot-quick-exploratory",
    "href": "content/01_practicals/02_basics-of-visualizing-mathematical-models/02-04_visualizing-single-strain-virulence-fitness.html#single-alpha-implicit-plot-quick-exploratory",
    "title": "Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "section": "4 Single \\(\\alpha\\), implicit plot (quick exploratory)",
    "text": "4 Single \\(\\alpha\\), implicit plot (quick exploratory)\n\nusing CairoMakie\n\n# Fitness model\nw(z, α) = z * (1 - α*z)\n\n# Choose a single α value\nα = 0.5\n\n# Generate z-values over the biologically meaningful range\nz_vals = range(0.0, 1/α; length = 400)\n\n# Evaluate the model on the grid\nw_vals = map(z -&gt; w(z, α), z_vals)\n\n# Quick plot with implicit Figure/Axis\nlines(z_vals, w_vals)\n\n\n\n\nThis produces one curve showing how fitness changes as host exploitation severity \\(z\\) increases, holding \\(\\alpha\\) fixed.\nMultiple \\(\\alpha\\) values on the same plot (explicit Figure and Axis) using CairoMakie\n\n# Fitness model\nw(z, α) = z * (1 - α*z)\n\n# Choose several α values to compare\nα_values = [0.2, 0.5, 1.0]\n\n# Create Figure and Axis explicitly\nfig = Figure()\nax = Axis(\n    fig[1, 1],\n    xlabel = \"host exploitation severity (z)\",\n    ylabel = \"parasite fitness (w)\",\n    title  = \"Fitness curves for different α\"\n)\n\n# Add one curve per α onto the same axis\nfor α in α_values\n    z_vals = range(0.0, 1/α; length = 400)\n    w_vals = map(z -&gt; w(z, α), z_vals)\n    lines!(ax, z_vals, w_vals, label = \"α = $(α)\")\nend\n\n# Add a legend\naxislegend(ax)\n\nfig\n\n\n\n\nHere, \\(\\alpha\\) plays the role of a parameter you “sweep” across several values, to see how the \\(w\\)–\\(z\\) relationship changes.\nSurface plot: fitness as a function of \\(z\\) and \\(\\alpha\\)\nTo visualize the full two-parameter relationship \\(w(z;\\alpha)\\), we evaluate \\(w\\) on a 2D grid of \\((z,\\alpha)\\) values and plot a surface.\n\nusing CairoMakie\n\n# Fitness model\nw(z, α) = z * (1 - α*z)\n\n# Grid of α values (parameter axis)\nα_vals = range(0.2, 1.0; length = 120)\n\n# Grid of z values (trait axis)\n# Use a common z-range for the surface; choose up to 1/max(α) so the full grid is comparable\nz_max = 1 / maximum(α_vals)\nz_vals = range(0.0, z_max; length = 200)\n\n# Evaluate w on the (z, α) grid:\n# W[i, j] = w(z_vals[i], α_vals[j])\nW = [w(z, α) for z in z_vals, α in α_vals]\n\n# Plot as a 3D surface\nfig = Figure()\nax3 = Axis3(\n    fig[1, 1],\n    xlabel = \"host exploitation severity (z)\",\n    ylabel = \"virulence scaling (α)\",\n    zlabel = \"parasite fitness (w)\",\n    title  = \"Fitness surface w(z; α)\"\n)\n\nsurface!(ax3, z_vals, α_vals, W)\n\nfig\n\n\n\n\nThis surface makes it visually explicit that \\(w\\) depends on both the trait value (\\(z\\)) and the environment/biology scaling parameter (\\(\\alpha\\)).\n\nExerciseSingle-curve practice (implicit plot)\nSet \\(\\alpha = 0.25\\) and reproduce the single-curve plot.\nIncrease the resolution by changing length = 400 to length = 2000.\nRestrict the plotted domain to \\(0 \\le z \\le \\frac{1}{2\\alpha}\\) and compare the shape to the full range \\(0 \\le z \\le \\frac{1}{\\alpha}\\).\n\n\n\nExerciseMultiple-curve practice (explicit Axis, adding curves)\nPlot curves for \\(\\alpha \\in {0.1, 0.2, 0.4, 0.8}\\) on the same axis.\nAdd a second axis below the first that plots the same curves using scatter! instead of lines!.\nChange axis labels and title so that the plot reads well when exported.\n\n\n\nExerciseSurface practice (2D grid evaluation)\nChange the \\(\\alpha\\) grid to range(0.1, 2.0; length = 200) and regenerate the surface.\nReplace the surface with a heatmap of \\(w\\) over \\((z,\\alpha)\\) using heatmap!(…).\nModify the grid so that, for each \\(\\alpha\\), you only include \\(z \\le 1/\\alpha\\) (the nonnegative-opportunity region) by setting \\(w(z,\\alpha) = NaN\\) whenever \\(z &gt; 1/\\alpha\\), and observe how the plotted region changes.",
    "crumbs": [
      "Practicals",
      "Basics of visualizing mathematical models",
      "Visualizing the single-strain parasite virulence-transmission balance fitness landscape"
    ]
  },
  {
    "objectID": "content/01_practicals/03_basics-of-working-with-stochastic-processes-and-distributions/index.html#the-rand-function",
    "href": "content/01_practicals/03_basics-of-working-with-stochastic-processes-and-distributions/index.html#the-rand-function",
    "title": "Random number generation",
    "section": "1 The rand function",
    "text": "1 The rand function\nThe rand function is the function we will most often use to generate random variates of different shapes, and sizes and characteristics. The rand function has a number of different methods for generating random values of various different data types, structures, and ranges. The core Julia provides a collection rand methods that generate values sampled from uniform distributions, (and a parallel collection of methods for sampling from the normal distribution, randn). Packages such as Distributions.jl provide the ability to generate random values sampled from a broader range of distributions.\n\n\n\n\n\n\n\nTipFunctions vs methods in Julia\n\n\n\nIn Julia, a function is a operation that can accept inputs and returns a value. A method is a specific implementation of that function for particular input types or argument combinations. When you call rand(), rand(Int), or rand(1:6), you are calling different methods of the same function. Julia automatically selects the appropriate method based on the types and number of arguments you provide, as long as someone (the Julia programmers, package programmers, or yourself) has written a function that takes combination of arguments, a mechanism called multiple dispatch.",
    "crumbs": [
      "Practicals",
      "Random number generation"
    ]
  },
  {
    "objectID": "content/01_practicals/03_basics-of-working-with-stochastic-processes-and-distributions/index.html#methods-of-the-rand-function",
    "href": "content/01_practicals/03_basics-of-working-with-stochastic-processes-and-distributions/index.html#methods-of-the-rand-function",
    "title": "Random number generation",
    "section": "2 Methods of the rand function",
    "text": "2 Methods of the rand function\n\n2.1 Sampling a uniform random value of a particular type\n\njulia&gt; rand(Int) # Generate a random integer\n-6581752414023885448\n\njulia&gt; rand(Float64) # Generate a random (64-bit) floating point\n0.5551313236725943\n\njulia&gt; rand(Int, 10) # Generate 10 random integers\n10-element Vector{Int64}:\n  7698269277784285493\n   119518414081352549\n -7810994830346528650\n -2227295384308136057\n -3787444672257423100\n  2454496437854673843\n -4688583217568250768\n  3428356285250979074\n   217784465829442243\n -2477159631785889726\n\njulia&gt; rand(Float64, 10) # Generate 10 random (64-bit) floating point values\n10-element Vector{Float64}:\n 0.8121004451418985\n 0.7498281699504885\n 0.262689399562409\n 0.551763388172788\n 0.7264346095273245\n 0.8899981043981576\n 0.4991116861348205\n 0.8177168948063814\n 0.8108662080895137\n 0.14549261534858948\n\n\n2.2 Sampling from a defined range or collection with uniform random probability\n\nrand(-500:500, 4) # Sample 4 integer numbers between -500 and 500\n\nrand([0.1, 0.2, 0.3, 0.4], 2) # Sample 2 values from the array of floating points [0.1, 0.2, 0.3, 0.4]\n\nrand(['A', 'C', 'G', 'T'], 3) # Sample 3 values from the array of characters ['A', 'C', 'G', 'T']\n\n\n2.3 Sampling random continuous values from \\((0, 1]\\) with uniform probability",
    "crumbs": [
      "Practicals",
      "Random number generation"
    ]
  },
  {
    "objectID": "content/01_practicals/03_basics-of-working-with-stochastic-processes-and-distributions/index.html#sampling-a-random-event-of-a-particular-probaility",
    "href": "content/01_practicals/03_basics-of-working-with-stochastic-processes-and-distributions/index.html#sampling-a-random-event-of-a-particular-probaility",
    "title": "Random number generation",
    "section": "3 Sampling a random event of a particular probaility",
    "text": "3 Sampling a random event of a particular probaility",
    "crumbs": [
      "Practicals",
      "Random number generation"
    ]
  },
  {
    "objectID": "content/01_practicals/02_basics-of-visualizing-mathematical-models/index.html#generating-a-sequence-of-values-with-the-range-function",
    "href": "content/01_practicals/02_basics-of-visualizing-mathematical-models/index.html#generating-a-sequence-of-values-with-the-range-function",
    "title": "Generating sequences of values using the range function",
    "section": "1 Generating a sequence of values with the range function",
    "text": "1 Generating a sequence of values with the range function\n\n\n\n\n\n\n\nNoteRange objects are algorithmic representation of ranges\n\n\n\nThe actual value returned by the range function are not actually arrays of values, but rather a special “lazy” range object, with “lazy” here being a program design term meaning that the resources (particularly memory) will be allocated only if and when needed. What this means is that you can construct very large collections of values, with large ranges and high resolution, but not pay the resource cost of holding all these values in memory at the same time.\njulia&gt; r = range(1e-10, 1e10; step = 0.001)\n1.0e-10:0.001:1.0e10\njulia&gt; length(r)\n10000000000001\njulia&gt; r[begin]\n1.0e-10\njulia&gt; r[end]\n1.0e10\njulia&gt; r[begin + 2]\n0.0020000001\njulia&gt; r[end - 4]\n9.999999999996e9\njulia&gt; r[1]\n1.0e-10\njulia&gt; r[2]\n0.0010000001\njulia&gt; r[3]\n0.0020000001\nTo actually generate the values, use the collect function, which will “unpack” the range object and return a Vector object (a single dimensional array) with the full sequence of values.\njulia&gt; r = range(0, 10; step = 2.5)\n0.0:2.5:10.0\n\njulia&gt; collect(r)\n5-element Vector{Float64}:\n 0.0\n 2.5\n 5.0\n 7.5\n10.0\n\nWe can generate a set of \\(x\\) values over a particular range of values, continuous or otherwise, using the range function in Julia. The range function has a number of different methods, but for our purposes we will focus on specifying the range in terms of a three parameters: a start value, a stop value, and either a step size (interval between consecutive values in the sequence),\njulia&gt; range(0, 10; step = 1)\n0:1:10\njulia&gt; range(0, 10; step = 0.2)\n0.0:0.2:10.0\njulia&gt; range(-10, 10; step = 2)\n-10:2:10\nor length (number of values) in the sequence,\njulia&gt; range(0, 10; length = 11)\n0.0:1.0:10.0\njulia&gt; range(0, 10; length = 5)\n0.0:2.5:10.0\njulia&gt; range(-1, 1; length = 20)\nThe range function has a short-hand syntax, start:step:stop:\njulia&gt; 0.0:2.5:10.0\n0.0:2.5:10.0\n\njulia&gt; collect(0.0:2.5:10.0)\n5-element Vector{Float64}:\n  0.0\n  2.5\n  5.0\n  7.5\n 10.0\n\njulia&gt; 0.0:2.5:10.0 == range(0, 10; step = 2.5)\ntrue",
    "crumbs": [
      "Practicals",
      "Generating sequences of values using the `range` function"
    ]
  },
  {
    "objectID": "content/01_practicals/02_basics-of-visualizing-mathematical-models/index.html#calculating-and-visualizing-function-values-over-a-sequence",
    "href": "content/01_practicals/02_basics-of-visualizing-mathematical-models/index.html#calculating-and-visualizing-function-values-over-a-sequence",
    "title": "Generating sequences of values using the range function",
    "section": "2 Calculating and visualizing function values over a sequence",
    "text": "2 Calculating and visualizing function values over a sequence\n\n\n\n\n\n\n\nTipmap: to apply a function to every element in a collection\n\n\n\nThe map function applies a given function to every element of a collection, returning a new collection of the results. map(x -&gt; 6x + 4, x_values) passes each value in x_values through the function (here an anonymous function, defined using the arrow function definition syntax, x -&gt; 6x + 4), one at a time, producing a corresponding output value for each. This is a common and idiomatic pattern in Julia: rather than writing an explicit loop, you map a transformation over a collection. The result has the same length and order as the input.\n\n\n\n\n\n\n\nTipAnonymous vs. named functions\n\n\n\nNote that here we passed map an anonymous function.\nAn anonymous function is a function defined without a name, typically for immediate or one-time use, using the arrow syntax, which list the input arguments of the left of the -&gt; and output on the right. For example,x -&gt; x^2 is an anonymous function that squares its input, while (n_apples, price_of_apple) -&gt; n_apples * price_of_apple calculates the price of a collection of apples.\nAnonymous functions are most commonly used when a function is simple and only needed in one place, defining it anonymously is cleaner than giving it a name. Typically, as functions get more complex, or for documentation and replicability reasons, we often prefer to use named functions.\n\nmodel1(x) = 6x + 4\n\nfunction model2(x) \n  x^2 + 2x + 3\nend\n\nmap(model1, x_values)\nmap(model2, x_values)\n\n\nWe calculate the \\(y\\) values corresponding to each \\(x\\) value generated by the range object using the map function, and visualize the relationship between the \\(x\\) and \\(y\\) points using the scatter function from the CairoMakie library:\n\nusing CairoMakie\nx_values = -10:0.01:10\ny_values = map(x -&gt; 6x + 4, x_values)\nscatter(x_values, y_values)\n\n\n\n\nor, if we do not need to store the \\(y\\) values beyond the visualization:\nusing CairoMakie\nX = -10:0.01:10\nscatter(X, map(x -&gt; 6x + 4, X))\n\n\nExercise\nVisualize larger ranges and higher resolutions (smaller steps) of \\(x\\)-values of this same model\n\\[\ny = 6x + 4\n\\]\nto see if the relationships change:\n\n\\(-1000 &lt; x &lt; 1000\\), with step sizes of 1.0\n\\(0 &lt; x &lt; 1.0\\), with step sizes of 0.001\n\n\n\n\n\nExercise\nVisualize the following models in terms of the relationship between the varibles under the specified ranges:\n\n\\(f(x) = \\frac{1}{x}, x \\in \\{1, 2, \\ldots, 100\\}\\)\n\\(f(x) = x^2, -10 \\le x \\le 10\\)",
    "crumbs": [
      "Practicals",
      "Generating sequences of values using the `range` function"
    ]
  },
  {
    "objectID": "content/01_practicals/02_basics-of-running-julia/index.html#running-julia-programs-the-julia-runtime-repl-and-program-files",
    "href": "content/01_practicals/02_basics-of-running-julia/index.html#running-julia-programs-the-julia-runtime-repl-and-program-files",
    "title": "Basics of setting up and running Julia",
    "section": "2 Running Julia programs: the Julia runtime, REPL, and program files",
    "text": "2 Running Julia programs: the Julia runtime, REPL, and program files",
    "crumbs": [
      "Practicals",
      "Basics of setting up and running Julia"
    ]
  },
  {
    "objectID": "content/01_practicals/02_basics-of-running-julia/index.html#working-with-julia-environments-projects-packages-and-package-management",
    "href": "content/01_practicals/02_basics-of-running-julia/index.html#working-with-julia-environments-projects-packages-and-package-management",
    "title": "Basics of setting up and running Julia",
    "section": "3 Working with Julia: environments, projects, packages, and package management",
    "text": "3 Working with Julia: environments, projects, packages, and package management\n\n3.1 Basic concepts\n\nThe Julia global environment\nProject environments\nWhen to use what\n\nConventional approaches span somewhere as a mix between two extremes:\n\nInstall and use everything out of the global environment, reserving project environment for specialized processing\nEVERYTHING is a project\n\nRecommendations:\n\nIf you are just starting, and really don’t want to get into the bells and whistles yet: don’t worry about it, go for the “one global environment to rule them all” approach\nWhether or not you are just starting, but you do want to take the more difficult but best-practices road:\n\nKeep your global environment clean\nCreate a global “general purpose scratchpad/calculator” environment, and use THAT for almost everything\nCreate project specific environments when you are working on a package or specialized projects.",
    "crumbs": [
      "Practicals",
      "Basics of setting up and running Julia"
    ]
  },
  {
    "objectID": "content/01_practicals/02_basics-of-running-julia/index.html#how-to-organize-your-code",
    "href": "content/01_practicals/02_basics-of-running-julia/index.html#how-to-organize-your-code",
    "title": "Basics of setting up and running Julia",
    "section": "4 How to organize your code",
    "text": "4 How to organize your code",
    "crumbs": [
      "Practicals",
      "Basics of setting up and running Julia"
    ]
  },
  {
    "objectID": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html",
    "href": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html",
    "title": "Basics of visualizing mathematical models",
    "section": "",
    "text": "This is an example of a mathematical model relating \\(y\\) values to \\(x\\):\n\nModel: A linear model\\(y = 6x + 4\\)\n\n\nTo visualize this in Julia, we generate sets \\(x\\) and \\(y\\) values conforming to the above relationship and pass these to the plotting function. These values may be generated systematically—a sequence generated by an algorithm—or stochastically—sampled from a probabilistic distribution. Here, we will discuss the first case.\nIn all cases, we have to ensure that the type and range of values conform to the assumptions of the model. In this example, The \\(x\\) and \\(y\\) values will be assumed to be, each, single-dimensional real values, \\(x, y \\in \\mathrm{R}^1\\), taking values in the entire real line. The \\(y\\) values here are deterministic functions of the \\(x\\) values, and so they can be calculated from the \\(x\\) values, once these have been generated.\n\n\n\n\n\n\n\n\n\n\nNoteRange objects are algorithmic representation of ranges\n\n\n\nThe actual value returned by the range function are not actually arrays of values, but rather a special “lazy” range object, with “lazy” here being a program design term meaning that the resources (particularly memory) will be allocated only if and when needed. What this means is that you can construct very large collections of values, with large ranges and high resolution, but not pay the resource cost of holding all these values in memory at the same time.\njulia&gt; r = range(1e-10, 1e10; step = 0.001)\n1.0e-10:0.001:1.0e10\njulia&gt; length(r)\n10000000000001\njulia&gt; r[begin]\n1.0e-10\njulia&gt; r[end]\n1.0e10\njulia&gt; r[begin + 2]\n0.0020000001\njulia&gt; r[end - 4]\n9.999999999996e9\njulia&gt; r[1]\n1.0e-10\njulia&gt; r[2]\n0.0010000001\njulia&gt; r[3]\n0.0020000001\nTo actually generate the values, use the collect function, which will “unpack” the range object and return a Vector object (a single dimensional array) with the full sequence of values.\njulia&gt; r = range(0, 10; step = 2.5)\n0.0:2.5:10.0\n\njulia&gt; collect(r)\n5-element Vector{Float64}:\n 0.0\n 2.5\n 5.0\n 7.5\n10.0\n\nWe can generate a set of \\(x\\) values over a particular range of values, continuous or otherwise, using the range function in Julia. The range function has a number of different methods, but for our purposes we will focus on specifying the range in terms of a three parameters: a start value, a stop value, and either a step size (interval between consecutive values in the sequence),\njulia&gt; range(0, 10; step = 1)\n0:1:10\njulia&gt; range(0, 10; step = 0.2)\n0.0:0.2:10.0\njulia&gt; range(-10, 10; step = 2)\n-10:2:10\nor length (number of values) in the sequence,\njulia&gt; range(0, 10; length = 11)\n0.0:1.0:10.0\njulia&gt; range(0, 10; length = 5)\n0.0:2.5:10.0\njulia&gt; range(-1, 1; length = 20)\nThe range function has a short-hand syntax, start:step:stop:\njulia&gt; 0.0:2.5:10.0\n0.0:2.5:10.0\n\njulia&gt; collect(0.0:2.5:10.0)\n5-element Vector{Float64}:\n  0.0\n  2.5\n  5.0\n  7.5\n 10.0\n\njulia&gt; 0.0:2.5:10.0 == range(0, 10; step = 2.5)\ntrue\n\n\n\n\n\n\n\n\n\n\nTipmap: to apply a function to every element in a collection\n\n\n\nThe map function applies a given function to every element of a collection, returning a new collection of the results. map(x -&gt; 6x + 4, x_values) passes each value in x_values through the function (here an anonymous function, defined using the arrow function definition syntax, x -&gt; 6x + 4), one at a time, producing a corresponding output value for each. This is a common and idiomatic pattern in Julia: rather than writing an explicit loop, you map a transformation over a collection. The result has the same length and order as the input.\n\n\n\n\n\n\n\nTipAnonymous vs. named functions\n\n\n\nNote that here we passed map an anonymous function.\nAn anonymous function is a function defined without a name, typically for immediate or one-time use, using the arrow syntax, which list the input arguments of the left of the -&gt; and output on the right. For example,x -&gt; x^2 is an anonymous function that squares its input, while (n_apples, price_of_apple) -&gt; n_apples * price_of_apple calculates the price of a collection of apples.\nAnonymous functions are most commonly used when a function is simple and only needed in one place, defining it anonymously is cleaner than giving it a name. Typically, as functions get more complex, or for documentation and replicability reasons, we often prefer to use named functions.\n\nmodel1(x) = 6x + 4\n\nfunction model2(x) \n  x^2 + 2x + 3\nend\n\nmap(model1, x_values)\nmap(model2, x_values)\n\n\nWe calculate the \\(y\\) values corresponding to each \\(x\\) value generated by the range object using the map function, and visualize the relationship between the \\(x\\) and \\(y\\) points using the scatter function from the CairoMakie library:\n\nusing CairoMakie\nx_values = -10:0.01:10\ny_values = map(x -&gt; 6x + 4, x_values)\nscatter(x_values, y_values)\n\n\n\n\nor, if we do not need to store the \\(y\\) values beyond the visualization:\nusing CairoMakie\nX = -10:0.01:10\nscatter(X, map(x -&gt; 6x + 4, X))\n\n\nExercise\nVisualize larger ranges and higher resolutions (smaller steps) of \\(x\\)-values of this same model\n\\[\ny = 6x + 4\n\\]\nto see if the relationships change:\n\n\\(-1000 &lt; x &lt; 1000\\), with step sizes of 1.0\n\\(0 &lt; x &lt; 1.0\\), with step sizes of 0.001\n\n\n\n\n\nExercise\nVisualize the following models in terms of the relationship between the varibles under the specified ranges:\n\n\\(f(x) = \\frac{1}{x}, x \\in \\{1, 2, \\ldots, 100\\}\\)\n\\(f(x) = x^2, -10 \\le x \\le 10\\)",
    "crumbs": [
      "Practicals",
      "Basics of visualizing mathematical models"
    ]
  },
  {
    "objectID": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html#generating-a-sequence-of-values-with-the-range-function",
    "href": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html#generating-a-sequence-of-values-with-the-range-function",
    "title": "Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "section": "1 Generating a sequence of values with the range function",
    "text": "1 Generating a sequence of values with the range function\n\n\n\n\n\n\n\nNoteRange objects are algorithmic representation of ranges\n\n\n\nThe actual value returned by the range function are not actually arrays of values, but rather a special “lazy” range object, with “lazy” here being a program design term meaning that the resources (particularly memory) will be allocated only if and when needed. What this means is that you can construct very large collections of values, with large ranges and high resolution, but not pay the resource cost of holding all these values in memory at the same time.\njulia&gt; r = range(1e-10, 1e10; step = 0.001)\n1.0e-10:0.001:1.0e10\njulia&gt; length(r)\n10000000000001\njulia&gt; r[begin]\n1.0e-10\njulia&gt; r[end]\n1.0e10\njulia&gt; r[begin + 2]\n0.0020000001\njulia&gt; r[end - 4]\n9.999999999996e9\njulia&gt; r[1]\n1.0e-10\njulia&gt; r[2]\n0.0010000001\njulia&gt; r[3]\n0.0020000001\nTo actually generate the values, use the collect function, which will “unpack” the range object and return a Vector object (a single dimensional array) with the full sequence of values.\njulia&gt; r = range(0, 10; step = 2.5)\n0.0:2.5:10.0\n\njulia&gt; collect(r)\n5-element Vector{Float64}:\n 0.0\n 2.5\n 5.0\n 7.5\n10.0\n\nWe can generate a set of \\(x\\) values over a particular range of values, continuous or otherwise, using the range function in Julia. The range function has a number of different methods, but for our purposes we will focus on specifying the range in terms of a three parameters: a start value, a stop value, and either a step size (interval between consecutive values in the sequence),\njulia&gt; range(0, 10; step = 1)\n0:1:10\njulia&gt; range(0, 10; step = 0.2)\n0.0:0.2:10.0\njulia&gt; range(-10, 10; step = 2)\n-10:2:10\nor length (number of values) in the sequence,\njulia&gt; range(0, 10; length = 11)\n0.0:1.0:10.0\njulia&gt; range(0, 10; length = 5)\n0.0:2.5:10.0\njulia&gt; range(-1, 1; length = 20)\nThe range function has a short-hand syntax, start:step:stop:\njulia&gt; 0.0:2.5:10.0\n0.0:2.5:10.0\n\njulia&gt; collect(0.0:2.5:10.0)\n5-element Vector{Float64}:\n  0.0\n  2.5\n  5.0\n  7.5\n 10.0\n\njulia&gt; 0.0:2.5:10.0 == range(0, 10; step = 2.5)\ntrue",
    "crumbs": [
      "Practicals",
      "Visualizing the single-strain parasite virulence-transmission balance fitness landscape"
    ]
  },
  {
    "objectID": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html#calculating-and-visualizing-function-values-over-a-sequence",
    "href": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html#calculating-and-visualizing-function-values-over-a-sequence",
    "title": "Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "section": "2 Calculating and visualizing function values over a sequence",
    "text": "2 Calculating and visualizing function values over a sequence\n\n\n\n\n\n\n\nTipmap: to apply a function to every element in a collection\n\n\n\nThe map function applies a given function to every element of a collection, returning a new collection of the results. map(x -&gt; 6x + 4, x_values) passes each value in x_values through the function (here an anonymous function, defined using the arrow function definition syntax, x -&gt; 6x + 4), one at a time, producing a corresponding output value for each. This is a common and idiomatic pattern in Julia: rather than writing an explicit loop, you map a transformation over a collection. The result has the same length and order as the input.\n\n\n\n\n\n\n\nTipAnonymous vs. named functions\n\n\n\nNote that here we passed map an anonymous function.\nAn anonymous function is a function defined without a name, typically for immediate or one-time use, using the arrow syntax, which list the input arguments of the left of the -&gt; and output on the right. For example,x -&gt; x^2 is an anonymous function that squares its input, while (n_apples, price_of_apple) -&gt; n_apples * price_of_apple calculates the price of a collection of apples.\nAnonymous functions are most commonly used when a function is simple and only needed in one place, defining it anonymously is cleaner than giving it a name. Typically, as functions get more complex, or for documentation and replicability reasons, we often prefer to use named functions.\n\nmodel1(x) = 6x + 4\n\nfunction model2(x) \n  x^2 + 2x + 3\nend\n\nmap(model1, x_values)\nmap(model2, x_values)\n\n\nWe calculate the \\(y\\) values corresponding to each \\(x\\) value generated by the range object using the map function, and visualize the relationship between the \\(x\\) and \\(y\\) points using the scatter function from the CairoMakie library:\n\nusing CairoMakie\nx_values = -10:0.01:10\ny_values = map(x -&gt; 6x + 4, x_values)\nscatter(x_values, y_values)\n\n\n\n\nor, if we do not need to store the \\(y\\) values beyond the visualization:\nusing CairoMakie\nX = -10:0.01:10\nscatter(X, map(x -&gt; 6x + 4, X))\n\n\nExercise\nVisualize larger ranges and higher resolutions (smaller steps) of \\(x\\)-values of this same model\n\\[\ny = 6x + 4\n\\]\nto see if the relationships change:\n\n\\(-1000 &lt; x &lt; 1000\\), with step sizes of 1.0\n\\(0 &lt; x &lt; 1.0\\), with step sizes of 0.001\n\n\n\n\n\nExercise\nVisualize the following models in terms of the relationship between the varibles under the specified ranges:\n\n\\(f(x) = \\frac{1}{x}, x \\in \\{1, 2, \\ldots, 100\\}\\)\n\\(f(x) = x^2, -10 \\le x \\le 10\\)\n\n\n\n\nProficiencies\n\nFor pilot and exploratory work: plotting without explicit Figure and Axis objects.\nCreating a Figure container object to hold all the plots.\nCreating an Axis object onto which you will do the plotting, and placing it in a Figure object.\nUsing a stock plotting functions to plot given 2-dimensional data (\\(x-\\) and \\(y\\)-coordinates, for example).\nSaving the figure to a file or displaying it in-situ.",
    "crumbs": [
      "Practicals",
      "Visualizing the single-strain parasite virulence-transmission balance fitness landscape"
    ]
  },
  {
    "objectID": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html#plotting-with-implict-axis-and-figure",
    "href": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html#plotting-with-implict-axis-and-figure",
    "title": "Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "section": "3 Plotting with implict Axis and Figure",
    "text": "3 Plotting with implict Axis and Figure\n\n\n# Load the graphical module\nusing CairoMakie\n\n# Generate x-values from 1 to 100\nx_vals = 1:100\n\n# Generate y-values from function applied to x-values\ny_vals = map(x -&gt; 3x + 2, x_vals)\n\n# Plot (and display) using the `scatter` function\nrender = scatter(x_vals, y_vals)\n\n# Save to file\n# save(\"scatter1.pdf\", render)\n# Show figure in the REPL\n# render.figure",
    "crumbs": [
      "Practicals",
      "Visualizing the single-strain parasite virulence-transmission balance fitness landscape"
    ]
  },
  {
    "objectID": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html#plotting-with-explicit-axis-and-figure-management",
    "href": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html#plotting-with-explicit-axis-and-figure-management",
    "title": "Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "section": "4 Plotting with explicit Axis and Figure management",
    "text": "4 Plotting with explicit Axis and Figure management\n\n# Load the graphical module\nusing CairoMakie\n\n# Create a `Figure` object\nfigure = Figure();\n\n# Create an `Axis` object, placing it in the center of the figure.\n# `[1, 1]` specifies cell (1, 1) of a grid that grows dynamically as \n# cells are specified. Here, as there is only one cell defined, it\n# effectively places the `Axis` object in the center of the `Figure`\n# object\nax = Axis(figure[1, 1])\n\n# Plot some data onto the Axis object\n\n# x-coordinate values: a sequence from 0.0 to 100.0, in 0.01 step increments\nx_vals = 0:0.1:100.0\n\n# y-coordinate values: a function of the x-coordinate values\n#\n# $$\n# y = 4 x^2 + 2 x + 3\n# $$\n#\ny_vals = map(x -&gt; 4(x^2) + 2x + 3, x_vals)\n\n# Plot using the `scatter!` function\n# Note: the name is `scatter!` not `scatter`, and we pass \n# in the Axis object `ax` as the first argument\nscatter!(ax, x_vals, y_vals)\n\n# Save to file\n# save(\"scatter1.pdf\", render)\n# Show figure in the REPL\n# render.figure\n\nScatter{Tuple{Vector{Point{2, Float64}}}}\n\n\n\nProficiencies",
    "crumbs": [
      "Practicals",
      "Visualizing the single-strain parasite virulence-transmission balance fitness landscape"
    ]
  },
  {
    "objectID": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html#parasite-fitness-function",
    "href": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html#parasite-fitness-function",
    "title": "Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "section": "5 Parasite fitness function",
    "text": "5 Parasite fitness function\n\nThe single-strain parasite fitness model is given as (Frank 1996):\nAs discussed in ?@sec-markov-property, the defining condition only depends on the present state.\n\\[\n\\begin{aligned}\nw = z (1 - \\alpha z)\n\\end{aligned}\n\\tag{1}\\]\nwhere:\n\n\\(w\\) is a measure of parasite fitness,\n\\(z\\) is a measure of the parasite host exploitation severity, correlating positively with parasite reproductive and host colonization capacity, and\n\\(\\alpha z\\) is a measure of virulence, the damage a parasite does to the host as a result of exploitation \\(z\\), with \\(\\alpha\\) a scaling factor, weighting the damage of the parasite reproductive activity in reducing the host resources available to the parasite.",
    "crumbs": [
      "Practicals",
      "Visualizing the single-strain parasite virulence-transmission balance fitness landscape"
    ]
  },
  {
    "objectID": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html#behavior-under-adaptive-evolution",
    "href": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html#behavior-under-adaptive-evolution",
    "title": "Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "section": "6 Behavior under adaptive evolution",
    "text": "6 Behavior under adaptive evolution\nLet us consider host exploitation severity, \\(z\\), as a heritable trait that affects transmission success and virulence, and let \\(w(z, \\alpha)\\) be the fitness of of a parasite with host exploitation severity trait value \\(z\\), given some virulence impact weight \\(\\alpha\\).\nIf parasites vary in \\(z\\) and this variation is heritable, then strategies with larger \\(w(z)\\) tend to leave more descendants (i.e., spread more effectively).\nIn this simplified model, we therefore expect evolution to favor values of \\(z\\) that make \\(w(z)\\) as large as possible, so we look for the value of \\(z\\) that maximizes \\(w(z)\\).\nConceptually, we can treat \\(z\\) as a control or tuning variable: it is the parasite strategy we imagine changing. The parameter \\(\\alpha\\) determines how strongly exploitation reduces host resources (how costly virulence is per unit increase in \\(z\\)). For a fixed \\(\\alpha\\), plotting \\(w\\) against \\(z\\) shows a trade-off: increasing \\(z\\) raises transmission potential, but beyond a point the virulence cost dominates and \\(w\\) declines.",
    "crumbs": [
      "Practicals",
      "Visualizing the single-strain parasite virulence-transmission balance fitness landscape"
    ]
  },
  {
    "objectID": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html#visualization-of-fitness-relationship-with-host-exploitation-severity",
    "href": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html#visualization-of-fitness-relationship-with-host-exploitation-severity",
    "title": "Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "section": "7 Visualization of fitness relationship with host exploitation severity",
    "text": "7 Visualization of fitness relationship with host exploitation severity\n\nProficiencies\n\nGenerating a 1D grid of input values with range (or start:step:stop).\nComputing model outputs over a grid with map.\nPlotting a single 2D relationship with an implicit figure/axis (quick exploratory plot).\nCreating an explicit Figure and Axis, and adding multiple curves to the same axis with ...! plotting functions.\nVisualizing a 2-parameter model as a surface by evaluating the model on a 2D grid.\n\n\n\nWe will visualize the single-strain fitness model\n\\[\nw(z;\\alpha) = z(1-\\alpha z),\n\\]\nwhere:\n\n\\(z\\) is host exploitation severity (the model’s adjustable trait variable),\n\\(\\alpha\\) is a fixed scaling parameter that determines how strongly exploitation reduces transmission opportunity,\n\\(w\\) is parasite fitness (new infected hosts per infected host under the model).\n\nIn Julia, we can generate a grid of \\(z\\) values, evaluate \\(w(z;\\alpha)\\), and plot \\(w\\) versus \\(z\\) for one or several choices of \\(\\alpha\\).\nWhen we plot \\(w\\) versus \\(z\\) for a fixed \\(\\alpha\\), we typically restrict to\n\\[\n0 \\le z \\le \\frac{1}{\\alpha},\n\\]\nso that the transmission-opportunity term \\((1-\\alpha z)\\) stays nonnegative.",
    "crumbs": [
      "Practicals",
      "Visualizing the single-strain parasite virulence-transmission balance fitness landscape"
    ]
  },
  {
    "objectID": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html#single-alpha-implicit-plot-quick-exploratory",
    "href": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html#single-alpha-implicit-plot-quick-exploratory",
    "title": "Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "section": "8 Single \\(\\alpha\\), implicit plot (quick exploratory)",
    "text": "8 Single \\(\\alpha\\), implicit plot (quick exploratory)\n\nusing CairoMakie\n\n# Fitness model\nw(z, α) = z * (1 - α*z)\n\n# Choose a single α value\nα = 0.5\n\n# Generate z-values over the biologically meaningful range\nz_vals = range(0.0, 1/α; length = 400)\n\n# Evaluate the model on the grid\nw_vals = map(z -&gt; w(z, α), z_vals)\n\n# Quick plot with implicit Figure/Axis\nlines(z_vals, w_vals)\n\n\n\n\nThis produces one curve showing how fitness changes as host exploitation severity \\(z\\) increases, holding \\(\\alpha\\) fixed.\nMultiple \\(\\alpha\\) values on the same plot (explicit Figure and Axis) using CairoMakie\n\n# Fitness model\nw(z, α) = z * (1 - α*z)\n\n# Choose several α values to compare\nα_values = [0.2, 0.5, 1.0]\n\n# Create Figure and Axis explicitly\nfig = Figure()\nax = Axis(\n    fig[1, 1],\n    xlabel = \"host exploitation severity (z)\",\n    ylabel = \"parasite fitness (w)\",\n    title  = \"Fitness curves for different α\"\n)\n\n# Add one curve per α onto the same axis\nfor α in α_values\n    z_vals = range(0.0, 1/α; length = 400)\n    w_vals = map(z -&gt; w(z, α), z_vals)\n    lines!(ax, z_vals, w_vals, label = \"α = $(α)\")\nend\n\n# Add a legend\naxislegend(ax)\n\nfig\n\n\n\n\nHere, \\(\\alpha\\) plays the role of a parameter you “sweep” across several values, to see how the \\(w\\)–\\(z\\) relationship changes.\nSurface plot: fitness as a function of \\(z\\) and \\(\\alpha\\)\nTo visualize the full two-parameter relationship \\(w(z;\\alpha)\\), we evaluate \\(w\\) on a 2D grid of \\((z,\\alpha)\\) values and plot a surface.\n\nusing CairoMakie\n\n# Fitness model\nw(z, α) = z * (1 - α*z)\n\n# Grid of α values (parameter axis)\nα_vals = range(0.2, 1.0; length = 120)\n\n# Grid of z values (trait axis)\n# Use a common z-range for the surface; choose up to 1/max(α) so the full grid is comparable\nz_max = 1 / maximum(α_vals)\nz_vals = range(0.0, z_max; length = 200)\n\n# Evaluate w on the (z, α) grid:\n# W[i, j] = w(z_vals[i], α_vals[j])\nW = [w(z, α) for z in z_vals, α in α_vals]\n\n# Plot as a 3D surface\nfig = Figure()\nax3 = Axis3(\n    fig[1, 1],\n    xlabel = \"host exploitation severity (z)\",\n    ylabel = \"virulence scaling (α)\",\n    zlabel = \"parasite fitness (w)\",\n    title  = \"Fitness surface w(z; α)\"\n)\n\nsurface!(ax3, z_vals, α_vals, W)\n\nfig\n\n\n\n\nThis surface makes it visually explicit that \\(w\\) depends on both the trait value (\\(z\\)) and the environment/biology scaling parameter (\\(\\alpha\\)).\n\nExerciseSingle-curve practice (implicit plot)\nSet \\(\\alpha = 0.25\\) and reproduce the single-curve plot.\nIncrease the resolution by changing length = 400 to length = 2000.\nRestrict the plotted domain to \\(0 \\le z \\le \\frac{1}{2\\alpha}\\) and compare the shape to the full range \\(0 \\le z \\le \\frac{1}{\\alpha}\\).\n\n\n\nExerciseMultiple-curve practice (explicit Axis, adding curves)\nPlot curves for \\(\\alpha \\in {0.1, 0.2, 0.4, 0.8}\\) on the same axis.\nAdd a second axis below the first that plots the same curves using scatter! instead of lines!.\nChange axis labels and title so that the plot reads well when exported.\n\n\n\nExerciseSurface practice (2D grid evaluation)\nChange the \\(\\alpha\\) grid to range(0.1, 2.0; length = 200) and regenerate the surface.\nReplace the surface with a heatmap of \\(w\\) over \\((z,\\alpha)\\) using heatmap!(…).\nModify the grid so that, for each \\(\\alpha\\), you only include \\(z \\le 1/\\alpha\\) (the nonnegative-opportunity region) by setting \\(w(z,\\alpha) = NaN\\) whenever \\(z &gt; 1/\\alpha\\), and observe how the plotted region changes.",
    "crumbs": [
      "Practicals",
      "Visualizing the single-strain parasite virulence-transmission balance fitness landscape"
    ]
  },
  {
    "objectID": "content/01_practicals/04_basics-of-working-with-random-numbers-and-distributions/index.html",
    "href": "content/01_practicals/04_basics-of-working-with-random-numbers-and-distributions/index.html",
    "title": "Random number generation",
    "section": "",
    "text": "Proficiencies\n\nHow to sample a single random value of a specified numeric type (e.g., Int, Float64) using rand.\nHow to sample a vector of random values of a specified type and length using rand.\nHow to sample a general \\(n \\times m\\) matrix of random values of a specified type using rand.\nHow to sample a single random Float64 value sampled uniformly from \\((0, 1]\\) using rand() with no arguments.\nHow to sample a vector of independent uniform random Float64 values in \\((0, 1]\\) by passing a length to rand.\nHow to sample a matrix of independent uniform random Float64 values in \\((0, 1]\\) by passing row and column dimensions to rand.\nHow to sample uniformly at random from a defined integer range using rand with a range argument (e.g., rand(-500:500, n)).\nHow to sample uniformly at random from an explicit collection of values (e.g., an array of floats or characters) using rand.",
    "crumbs": [
      "Practicals",
      "Random number generation"
    ]
  },
  {
    "objectID": "content/01_practicals/04_basics-of-working-with-random-numbers-and-distributions/index.html#the-rand-function",
    "href": "content/01_practicals/04_basics-of-working-with-random-numbers-and-distributions/index.html#the-rand-function",
    "title": "Random number generation",
    "section": "1 The rand function",
    "text": "1 The rand function\nThe rand function is the function we will most often use to generate random variates of different shapes, and sizes and characteristics. The rand function has a number of different methods, that is, different approaches for generating random values of various different data types, structures, and ranges, depending on the arguments passed to it. The core Julia library provides rand methods that generate values by sampling them from ranges and collections under a uniform probability distribution. Packages such as Distributions.jl, covered separately, provide the ability to sample random values from a broader range of distributions.\n\n\n\n\n\n\n\nTipFunctions vs methods in Julia\n\n\n\nIn Julia, a function is a operation that can accept inputs and returns a value. A method is a specific implementation of that function for particular input types or argument combinations. When you call rand(), rand(Int), or rand(1:6), you are calling different methods of the same function. Julia automatically selects the appropriate method based on the types and number of arguments you provide, as long as someone (the Julia programmers, package programmers, or yourself) has written a function that takes combination of arguments, a mechanism called multiple dispatch.",
    "crumbs": [
      "Practicals",
      "Random number generation"
    ]
  },
  {
    "objectID": "content/01_practicals/04_basics-of-working-with-random-numbers-and-distributions/index.html#methods-of-the-rand-function",
    "href": "content/01_practicals/04_basics-of-working-with-random-numbers-and-distributions/index.html#methods-of-the-rand-function",
    "title": "Random number generation",
    "section": "2 Methods of the rand function",
    "text": "2 Methods of the rand function\n\n2.1 Generating a value of a particular type sampled with uniform probability from its entire range\n\n\n# Sample an integer between its smallest and largest representible value with uniform random probability\nrand(Int) \n\n# Sample a random real (continuous or floating-point) value from across its 64-bit representation range with uniform random probability\nrand(Float64) \n\n# Sample a random character value from across its possible values with uniform random probability\nrand(Char)\n\n'\\U8ca5d': Unicode U+8CA5D (category Cn: Other, not assigned)\n\n\n\n\n2.2 Generating collections of values of a particular type sampled with uniform probability from their entire ranges\n\n# Vector of 10 i.i.d uniformly-distributed integers \nrand(Int, 10) \n\n# Sample 10 random (64-bit) floating point values\nrand(Float64, 10) \n\n10-element Vector{Float64}:\n 0.10202301490182919\n 0.41738381349526565\n 0.4783705488113673\n 0.05951340921029569\n 0.3847466115641427\n 0.2298550983450468\n 0.3164402164765243\n 0.9992406343727849\n 0.31611726912499793\n 0.5435624061525429\n\n\n\n\n2.3 Sampling a matrix of uniform random values of a particular type from across their entire ranges\nMultidimensional collections of values can be generated by the syntax, rand(Type, n, m), where n is the number of rows and m the number of columns.\njulia&gt; rand(Int, 2, 3) # Sample a $2 \\times 3$ matrix of random `Int` values.\n2×3 Matrix{Int64}:\n  4509280923847162819  -2134857291038475610   7823641098234751823\n -1923847561029384756   8234761029384756102  -3948572019384756021\n\njulia&gt; rand(Float64, 2, 3) # Sample a $2 \\times 3$ matrix of random `Float64` values.\n2×3 Matrix{Float64}:\n 0.731902  0.184771  0.992814\n 0.442018  0.661203  0.107552\n\n\n2.4 Sampling with uniform probability over given ranges\nWe can use methods of the rand function that take range objects to constrain the values to particular ranges. Instead of a type (Int, Float64, and so on), we can pass the rand function a range object to sample with uniform probability from the intervals or collections of values represented by the range object.\n\n# Sample 10 integer values from the closed interval [-5, 5] with uniform random probability.\nrand(-5:5, 10) \n# Sample 10 real values from the closed interval [-5.0, 5.0] (binned into 0.1 units) with uniform random probability\nrand(-5.0:0.1:5.0, 10)\n\n10-element Vector{Float64}:\n  2.3\n  3.1\n  0.3\n -0.5\n -0.1\n  2.2\n  4.1\n  1.1\n  3.5\n  2.3\n\n\n\n\n2.5 Sampling with uniform probability over given collections (with replacement)\nrand([0.1, 0.2, 0.3, 0.4], 2) # Sample 2 values with uniform probability replacement from the array of floating points [0.1, 0.2, 0.3, 0.4]\n\n# Sample 3 values with uniform probability and replacement from the array of characters ['A', 'C', 'G', 'T']\nrand(['A', 'C', 'G', 'T'], 3) \n\n# Sample 6 values with uniform probability and replacement from the array of strings\nrand([\"Frodo\", \"Gandalf\", \"Eowyn\", ], 4) \n::: [.callout-note title=“Ranges vs. collections” .column-margin}\nrand(0:1, , 10) # Sample 10 integer values from the interval $[0, 1]$\nrand([0, 1], , 10) # Sample 10 values from the collection of values given by the vector `[0, 1]`\n:::\n\n\n2.6 Sampling random continuous values from \\((0, 1]\\) with uniform probability\nSample a single random Float64 sampled uniformly from $(0, 1]`.\njulia&gt; rand() \n0.3748291736402814\nSample a vector of 5 independent uniform random values in \\((0, 1]\\).\njulia&gt; rand(5)\n5-element Vector{Float64}:\n 0.9182719048123472\n 0.1048821937401286\n 0.5529018823740193\n 0.7712039183746501\n 0.3391184720193847\nSample a \\(2 \\times 3\\) matrix of independent uniform random values in \\((0, 1]\\).\njulia&gt; rand(2, 3)\n2×3 Matrix{Float64}:\n 0.731902  0.184771  0.992814\n 0.442018  0.661203  0.107552",
    "crumbs": [
      "Practicals",
      "Random number generation"
    ]
  },
  {
    "objectID": "content/01_practicals/04_basics-of-working-with-random-numbers-and-distributions/index.html#sampling-a-random-event-of-a-particular-probaility",
    "href": "content/01_practicals/04_basics-of-working-with-random-numbers-and-distributions/index.html#sampling-a-random-event-of-a-particular-probaility",
    "title": "Random number generation",
    "section": "3 Sampling a random event of a particular probaility",
    "text": "3 Sampling a random event of a particular probaility",
    "crumbs": [
      "Practicals",
      "Random number generation"
    ]
  },
  {
    "objectID": "content/02_primers/models/frank1996model_virulence-transmission-tradeoff.html",
    "href": "content/02_primers/models/frank1996model_virulence-transmission-tradeoff.html",
    "title": "Virulence-transmission trade-off (Frank, 1996)",
    "section": "",
    "text": "The classical virulence-transmission trade-off function, following the notation of (Frank 1996), is:\n\\[\nR_0 = \\frac{\\beta(\\nu)N}{\\delta + \\nu + c(\\nu)},\n\\]\nwhere:\n\n\\(R_0\\) The basic reproduction number. The expected number of secondary infections produced by a single infected host introduced into a fully susceptible population of size \\(N\\). The transmission intensity multiplied by mean infectious duration.\n\\(\\nu\\) Virulence. In this formulation, \\(\\nu\\) is the disease-induced host mortality intensity. This represents the per-capita hazard at which infected hosts die because of the pathogen.\n\\(\\beta(\\nu)\\) Transmission coefficient (often called the transmission intensity). It gives the per-capita rate at which an infected host generates new infections per susceptible host, and it is assumed to depend on virulence. The biological trade-off is encoded here: increasing \\(\\nu\\) may increase within-host replication and hence transmission, so \\(\\beta'(\\nu) &gt; 0\\) over some range.\n\\(N\\) Total density (or number) of susceptible hosts in the population at invasion. Because \\(R_0\\) is defined at the start of an epidemic, essentially all hosts are susceptible, so the force of infection scales with \\(N\\).\n\\(\\delta\\) Background host mortality intensity (natural death intensity unrelated to infection). This removes infected hosts independently of the pathogen’s virulence.\n\\(c(\\nu)\\) Additional loss intensity associated with infection that is not direct mortality. Examples include recovery with immunity, behavioral isolation, treatment, or reduced contact rate induced by symptoms. It may depend on virulence if, for example, more virulent infections provoke faster immune clearance or stronger behavioral avoidance.\n\n\n\n\n\n\n\n\nTipIntensity vs. rate\n\n\n\nAll intensities are rates, but not all rates are intensities. A rate is a general term indicating the change of one quantity relative to another, expresed as a ratio (“rate” and “ratio” have the same linguistic root). An “intensity” is a rate, but one some characteristics is the instantaneous hazard parameter (= rate) of a stochastic process. In classical ODE epidemic models (e.g., SIR), “rate” and “intensity” are often used interchangeably because constant hazards produce exponential waiting times and yield linear per-capita ODE terms.\n\nNote that:\n\\[\nR_0 = \\text{transmission intensity} \\times \\text{mean infection duration}.\n\\]\n\nThe numerator, \\(\\beta(\\nu)N\\), is the transmission intensity, i.e. the per-capita intensity (or rate) of generating new infections in a population of size \\(N\\).\nThe denominator \\(\\delta + \\nu + c(\\nu)\\) gives the total removal intensity of infected hosts: the rate of removal of infected hosts from the population. Thus, \\(\\frac{1}{\\delta + \\nu + c(\\nu)}\\) gives the mean infectious duration.\n\nAs \\(R_0\\) measures the net increase of infected host over time, expressed as a ratio of infected hosts gain (the numerator) to infected hosts lost (the denominator), it serves as an index of the epidemiological state of an infectious disease. - If the numerator is greater than the denominator, there will be more infections generated than removed from the population, leading to a net increase in infections: the disease in an epidemic phase. - If the numerator is less than the denominator, there infections will be removed from the population faster than new infections will occur: the disease will “die out” without becoming an epidemic.\n\n\n\n\n Back to topReferences\n\nFrank, Steven A. 1996. “Models of Parasite Virulence.” The Quarterly Review of Biology 71 (1): 37–78. https://doi.org/10.1086/419267."
  },
  {
    "objectID": "content/02_primers/models/frank1996model_single-strain-parasite-fitness.html",
    "href": "content/02_primers/models/frank1996model_single-strain-parasite-fitness.html",
    "title": "Pathogen fitness as a function of virulence (Frank, 1996)",
    "section": "",
    "text": "(Frank 1996) provides an alternate formulation of virulence-transmission trade-off which defines pathogen fitness as a product of increase in capacity for transmission success for a particular pathogen reproductive intensity, weighted or scaled by the reduction in opportunity, duration, or effectiveness in transmission due to damage to the host due to the virulence of that reproductive intensity.\nThe fitness of a pathogen can be measured by the net gain in infected hosts, \\(w\\),\n\\[\nw = z f(z),\n\\tag{1}\\]\nwhere:\n\n\\(w\\) is the pathogen fitness (corresponding to \\(R_0\\), the net total reproductive output of the virus in terms of newly infected hosts),\n\\(z\\) is a measure correlated positively with parasite reproductive intensity, which correlates positively with capacity for transmission success, as measured by the number of hosts infected by a single infected host given full transmission opportunity (if host fitness, longevity, resources, mobility, etc. were not impacted by virus reproductive activity),\n\\(f(z)\\), a “declining function of \\(z\\)” (meaning that \\(f(z)\\) decreases as \\(z\\) increases), which is the cost or penalty factor accounting for reduction in transmission success due to depletion of host resources, fitness, longevity and so on as a result of pa."
  },
  {
    "objectID": "content/02_primers/models/frank1996model_single-strain-parasite-fitness.html#pathogen-fitness-as-function-of-virulence",
    "href": "content/02_primers/models/frank1996model_single-strain-parasite-fitness.html#pathogen-fitness-as-function-of-virulence",
    "title": "Pathogen fitness as a function of virulence (Frank, 1996)",
    "section": "",
    "text": "(Frank 1996) provides an alternate formulation of virulence-transmission trade-off which defines pathogen fitness as a product of increase in capacity for transmission success for a particular pathogen reproductive intensity, weighted or scaled by the reduction in opportunity, duration, or effectiveness in transmission due to damage to the host due to the virulence of that reproductive intensity.\nThe fitness of a pathogen can be measured by the net gain in infected hosts, \\(w\\),\n\\[\nw = z f(z),\n\\tag{1}\\]\nwhere:\n\n\\(w\\) is the pathogen fitness (corresponding to \\(R_0\\), the net total reproductive output of the virus in terms of newly infected hosts),\n\\(z\\) is a measure correlated positively with parasite reproductive intensity, which correlates positively with capacity for transmission success, as measured by the number of hosts infected by a single infected host given full transmission opportunity (if host fitness, longevity, resources, mobility, etc. were not impacted by virus reproductive activity),\n\\(f(z)\\), a “declining function of \\(z\\)” (meaning that \\(f(z)\\) decreases as \\(z\\) increases), which is the cost or penalty factor accounting for reduction in transmission success due to depletion of host resources, fitness, longevity and so on as a result of pa."
  },
  {
    "objectID": "content/02_primers/models/frank1996model_single-strain-parasite-fitness.html#linear-decline-in-host-resources-due-to-virulence",
    "href": "content/02_primers/models/frank1996model_single-strain-parasite-fitness.html#linear-decline-in-host-resources-due-to-virulence",
    "title": "Pathogen fitness as a function of virulence (Frank, 1996)",
    "section": "2 Linear decline in host resources due to virulence",
    "text": "2 Linear decline in host resources due to virulence\n(Frank 1996) describes a linear function to model the degradation of the host resources available due to virulence, \\(f(z) = 1 - \\alpha z\\), where \\(\\alpha\\) is a scaling relation between transmission (\\(z\\)) and virulence (\\(\\alpha z\\)).\nThe pathogen fitness function under this linear scaling is\n\\[\n\\begin{align}\nw = z (1 - \\alpha z)\n\\end{align}\n\\tag{2}\\]"
  },
  {
    "objectID": "content/01_practicals/01_orientation-and-tooling/index.html#shell-and-file-system-essentials",
    "href": "content/01_practicals/01_orientation-and-tooling/index.html#shell-and-file-system-essentials",
    "title": "Introduction, orientation, and tooling",
    "section": "2 Shell and file-system essentials",
    "text": "2 Shell and file-system essentials\n\nProficiencies\n\nHow to open a “shell” instance (“terminal”, “command-line”).\nHow to identify the current working directory path.\nHow to list the contents of the current working directory.\nHow to list the contents of any directory given relative and absolute paths.\nHow to change the current working directory based on:\n\nrelative paths\nabsolute paths\n\nHow to specify the location of a directory or a file as an argument to a program using both relative paths and absolute paths.\nHow to communicate or correlate file and directory locations presented in the operating system graphical interface (GUI) as or with path string specifiers in the shell.\nHow to create a new directory.\nHow to rename or move a directory.\nHow to rename or move a file.\nHow to copy a directory.\nHow to copy a file.",
    "crumbs": [
      "Practicals",
      "Introduction, orientation, and tooling"
    ]
  },
  {
    "objectID": "content/01_practicals/01_orientation-and-tooling/index.html#section",
    "href": "content/01_practicals/01_orientation-and-tooling/index.html#section",
    "title": "Introduction, orientation, and tooling",
    "section": "3 ",
    "text": "3",
    "crumbs": [
      "Practicals",
      "Introduction, orientation, and tooling"
    ]
  },
  {
    "objectID": "content/01_practicals/01_orientation-and-tooling/index.html#visual-studio-code-vs-code",
    "href": "content/01_practicals/01_orientation-and-tooling/index.html#visual-studio-code-vs-code",
    "title": "Introduction, orientation, and tooling",
    "section": "3 Visual Studio Code (VS Code)",
    "text": "3 Visual Studio Code (VS Code)",
    "crumbs": [
      "Practicals",
      "Introduction, orientation, and tooling"
    ]
  },
  {
    "objectID": "content/01_practicals/01_orientation-and-tooling/index.html#other-tooling",
    "href": "content/01_practicals/01_orientation-and-tooling/index.html#other-tooling",
    "title": "Introduction, orientation, and tooling",
    "section": "4 Other tooling",
    "text": "4 Other tooling",
    "crumbs": [
      "Practicals",
      "Introduction, orientation, and tooling"
    ]
  },
  {
    "objectID": "content/01_practicals/01_orientation-and-tooling/index.html#file-system-essentials",
    "href": "content/01_practicals/01_orientation-and-tooling/index.html#file-system-essentials",
    "title": "Introduction, orientation, and tooling",
    "section": "2 File-system essentials",
    "text": "2 File-system essentials\n\nProficiencies\nFile system concepts:\n\nSpatial metaphor of “location” in a hierarchical tree of folders and files.\nThe current working directory.\nSpecifying a location using a “path” string.\nSpecifying absolute vs. relative paths.\nProgram or executable pathss.\nStandard file-system organization",
    "crumbs": [
      "Practicals",
      "Introduction, orientation, and tooling"
    ]
  },
  {
    "objectID": "content/01_practicals/01_orientation-and-tooling/index.html#shell-essentials",
    "href": "content/01_practicals/01_orientation-and-tooling/index.html#shell-essentials",
    "title": "Introduction, orientation, and tooling",
    "section": "3 Shell essentials",
    "text": "3 Shell essentials\n\nProficiencies\n\nHow to open a “shell” instance (“terminal”, “command-line”).\nHow to identify the current working directory path.\nHow to list the contents of the current working directory.\nHow to list the contents of any directory given relative and absolute paths.\nHow to change the current working directory based on:\n\nrelative paths\nabsolute paths\n\nHow to specify the location of a directory or a file as an argument to a program using both relative paths and absolute paths.\nHow to communicate or correlate file and directory locations presented in the operating system graphical interface (GUI) as or with path string specifiers in the shell.\nHow to create a new directory.\nHow to rename or move a directory.\nHow to rename or move a file.\nHow to copy a directory.\nHow to copy a file.",
    "crumbs": [
      "Practicals",
      "Introduction, orientation, and tooling"
    ]
  },
  {
    "objectID": "content/01_practicals/index.html#chapter-1.-introduction-orientation-and-tooling",
    "href": "content/01_practicals/index.html#chapter-1.-introduction-orientation-and-tooling",
    "title": "Practicals",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences",
    "crumbs": [
      "Practicals"
    ]
  },
  {
    "objectID": "content/01_practicals/index.html#chapter-2.-basics-of-setting-up-and-running-julia",
    "href": "content/01_practicals/index.html#chapter-2.-basics-of-setting-up-and-running-julia",
    "title": "Practicals",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences",
    "crumbs": [
      "Practicals"
    ]
  },
  {
    "objectID": "content/01_practicals/index.html#chapter-3.-visualizing-the-single-strain-parasite-virulence-transmission-balance-fitness-landscape",
    "href": "content/01_practicals/index.html#chapter-3.-visualizing-the-single-strain-parasite-virulence-transmission-balance-fitness-landscape",
    "title": "Practicals",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences",
    "crumbs": [
      "Practicals"
    ]
  },
  {
    "objectID": "content/01_practicals/index.html#chapter-4.-random-number-generation",
    "href": "content/01_practicals/index.html#chapter-4.-random-number-generation",
    "title": "Practicals",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Practicals"
    ]
  },
  {
    "objectID": "content/01_practicals/index.html#introduction-orientation-and-tooling",
    "href": "content/01_practicals/index.html#introduction-orientation-and-tooling",
    "title": "Practicals",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences",
    "crumbs": [
      "Practicals"
    ]
  },
  {
    "objectID": "content/01_practicals/index.html#basics-of-setting-up-and-running-julia",
    "href": "content/01_practicals/index.html#basics-of-setting-up-and-running-julia",
    "title": "Practicals",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences",
    "crumbs": [
      "Practicals"
    ]
  },
  {
    "objectID": "content/01_practicals/index.html#visualizing-the-single-strain-parasite-virulence-transmission-balance-fitness-landscape",
    "href": "content/01_practicals/index.html#visualizing-the-single-strain-parasite-virulence-transmission-balance-fitness-landscape",
    "title": "Practicals",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences",
    "crumbs": [
      "Practicals"
    ]
  },
  {
    "objectID": "content/01_practicals/index.html#random-number-generation",
    "href": "content/01_practicals/index.html#random-number-generation",
    "title": "Practicals",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Practicals"
    ]
  },
  {
    "objectID": "content/02_primers/index.html#pathogen-fitness-as-a-function-of-virulence-frank-1996",
    "href": "content/02_primers/index.html#pathogen-fitness-as-a-function-of-virulence-frank-1996",
    "title": "Primers",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\nPracticals: visualization",
    "crumbs": [
      "Primers"
    ]
  },
  {
    "objectID": "content/02_primers/index.html#virulence-transmission-trade-off-frank-1996",
    "href": "content/02_primers/index.html#virulence-transmission-trade-off-frank-1996",
    "title": "Primers",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Primers"
    ]
  },
  {
    "objectID": "content/02_primers/index.html#markov-property",
    "href": "content/02_primers/index.html#markov-property",
    "title": "Primers",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences",
    "crumbs": [
      "Primers"
    ]
  },
  {
    "objectID": "content/02_primers/index.html#pseudo-random-number-generators",
    "href": "content/02_primers/index.html#pseudo-random-number-generators",
    "title": "Primers",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences",
    "crumbs": [
      "Primers"
    ]
  },
  {
    "objectID": "content/02_primers/index.html#pseudo-random-number-generators-best-practices",
    "href": "content/02_primers/index.html#pseudo-random-number-generators-best-practices",
    "title": "Primers",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences",
    "crumbs": [
      "Primers"
    ]
  },
  {
    "objectID": "content/02_primers/index.html#pseudo-random-number-generators-continuous-values-from-discrete-machines",
    "href": "content/02_primers/index.html#pseudo-random-number-generators-continuous-values-from-discrete-machines",
    "title": "Primers",
    "section": "",
    "text": "No matching items",
    "crumbs": [
      "Primers"
    ]
  },
  {
    "objectID": "index.html#introduction-orientation-and-tooling",
    "href": "index.html#introduction-orientation-and-tooling",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Introduction, orientation, and tooling",
    "text": "Introduction, orientation, and tooling",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#basics-of-setting-up-and-running-julia",
    "href": "index.html#basics-of-setting-up-and-running-julia",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Basics of setting up and running Julia",
    "text": "Basics of setting up and running Julia",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#visualizing-the-single-strain-parasite-virulence-transmission-balance-fitness-landscape",
    "href": "index.html#visualizing-the-single-strain-parasite-virulence-transmission-balance-fitness-landscape",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "text": "Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#random-number-generation",
    "href": "index.html#random-number-generation",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Random number generation",
    "text": "Random number generation\nNo matching items",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#practicals",
    "href": "index.html#practicals",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#primers",
    "href": "index.html#primers",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#practicals-1",
    "href": "index.html#practicals-1",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "5 Practicals",
    "text": "5 Practicals\n\n\n\n\n\n\nNoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#markov-property",
    "href": "index.html#markov-property",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Markov property",
    "text": "Markov property",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#pathogen-fitness-as-a-function-of-virulence-frank-1996",
    "href": "index.html#pathogen-fitness-as-a-function-of-virulence-frank-1996",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Pathogen fitness as a function of virulence (Frank, 1996)",
    "text": "Pathogen fitness as a function of virulence (Frank, 1996)",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#primers-1",
    "href": "index.html#primers-1",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Primers",
    "text": "Primers",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#pseudo-random-number-generators",
    "href": "index.html#pseudo-random-number-generators",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Pseudo-random number generators",
    "text": "Pseudo-random number generators",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#pseudo-random-number-generators-best-practices",
    "href": "index.html#pseudo-random-number-generators-best-practices",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Pseudo-random number generators: best practices",
    "text": "Pseudo-random number generators: best practices",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#pseudo-random-number-generators-continuous-values-from-discrete-machines",
    "href": "index.html#pseudo-random-number-generators-continuous-values-from-discrete-machines",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Pseudo-random number generators: continuous values from discrete machines",
    "text": "Pseudo-random number generators: continuous values from discrete machines",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#virulence-transmission-trade-off-frank-1996",
    "href": "index.html#virulence-transmission-trade-off-frank-1996",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Virulence-transmission trade-off (Frank, 1996)",
    "text": "Virulence-transmission trade-off (Frank, 1996)\nNo matching items",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#chapter-1.-introduction-orientation-and-tooling",
    "href": "index.html#chapter-1.-introduction-orientation-and-tooling",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Chapter 1. Introduction, orientation, and tooling",
    "text": "Chapter 1. Introduction, orientation, and tooling",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#chapter-2.-basics-of-setting-up-and-running-julia",
    "href": "index.html#chapter-2.-basics-of-setting-up-and-running-julia",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Chapter 2. Basics of setting up and running Julia",
    "text": "Chapter 2. Basics of setting up and running Julia",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#chapter-3.-visualizing-the-single-strain-parasite-virulence-transmission-balance-fitness-landscape",
    "href": "index.html#chapter-3.-visualizing-the-single-strain-parasite-virulence-transmission-balance-fitness-landscape",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Chapter 3. Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "text": "Chapter 3. Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#chapter-4.-random-number-generation",
    "href": "index.html#chapter-4.-random-number-generation",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Chapter 4. Random number generation",
    "text": "Chapter 4. Random number generation\nNo matching items",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#chapter-1.-markov-property",
    "href": "index.html#chapter-1.-markov-property",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Chapter 1. Markov property",
    "text": "Chapter 1. Markov property",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#chapter-2.-pathogen-fitness-as-a-function-of-virulence-frank-1996",
    "href": "index.html#chapter-2.-pathogen-fitness-as-a-function-of-virulence-frank-1996",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Chapter 2. Pathogen fitness as a function of virulence (Frank, 1996)",
    "text": "Chapter 2. Pathogen fitness as a function of virulence (Frank, 1996)",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#chapter-3.-primers",
    "href": "index.html#chapter-3.-primers",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Chapter 3. Primers",
    "text": "Chapter 3. Primers",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#chapter-4.-pseudo-random-number-generators",
    "href": "index.html#chapter-4.-pseudo-random-number-generators",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Chapter 4. Pseudo-random number generators",
    "text": "Chapter 4. Pseudo-random number generators",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#chapter-5.-pseudo-random-number-generators-best-practices",
    "href": "index.html#chapter-5.-pseudo-random-number-generators-best-practices",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Chapter 5. Pseudo-random number generators: best practices",
    "text": "Chapter 5. Pseudo-random number generators: best practices",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#chapter-6.-pseudo-random-number-generators-continuous-values-from-discrete-machines",
    "href": "index.html#chapter-6.-pseudo-random-number-generators-continuous-values-from-discrete-machines",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Chapter 6. Pseudo-random number generators: continuous values from discrete machines",
    "text": "Chapter 6. Pseudo-random number generators: continuous values from discrete machines",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#chapter-7.-virulence-transmission-trade-off-frank-1996",
    "href": "index.html#chapter-7.-virulence-transmission-trade-off-frank-1996",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Chapter 7. Virulence-transmission trade-off (Frank, 1996)",
    "text": "Chapter 7. Virulence-transmission trade-off (Frank, 1996)\nNo matching items",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "content/02_primers/index.html#chapter-1.-pathogen-fitness-as-a-function-of-virulence-frank-1996",
    "href": "content/02_primers/index.html#chapter-1.-pathogen-fitness-as-a-function-of-virulence-frank-1996",
    "title": "Primers",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\nPracticals: visualization",
    "crumbs": [
      "Primers"
    ]
  },
  {
    "objectID": "content/02_primers/index.html#chapter-2.-virulence-transmission-trade-off-frank-1996",
    "href": "content/02_primers/index.html#chapter-2.-virulence-transmission-trade-off-frank-1996",
    "title": "Primers",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences",
    "crumbs": [
      "Primers"
    ]
  },
  {
    "objectID": "content/02_primers/index.html#chapter-3.-markov-property",
    "href": "content/02_primers/index.html#chapter-3.-markov-property",
    "title": "Primers",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences",
    "crumbs": [
      "Primers"
    ]
  },
  {
    "objectID": "content/02_primers/index.html#chapter-4.-pseudo-random-number-generators",
    "href": "content/02_primers/index.html#chapter-4.-pseudo-random-number-generators",
    "title": "Primers",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences",
    "crumbs": [
      "Primers"
    ]
  },
  {
    "objectID": "content/02_primers/index.html#chapter-5.-pseudo-random-number-generators-best-practices",
    "href": "content/02_primers/index.html#chapter-5.-pseudo-random-number-generators-best-practices",
    "title": "Primers",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences",
    "crumbs": [
      "Primers"
    ]
  },
  {
    "objectID": "content/02_primers/index.html#chapter-6.-pseudo-random-number-generators-continuous-values-from-discrete-machines",
    "href": "content/02_primers/index.html#chapter-6.-pseudo-random-number-generators-continuous-values-from-discrete-machines",
    "title": "Primers",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Primers"
    ]
  },
  {
    "objectID": "index.html#chapter-3.-pseudo-random-number-generators",
    "href": "index.html#chapter-3.-pseudo-random-number-generators",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Chapter 3. Pseudo-random number generators",
    "text": "Chapter 3. Pseudo-random number generators",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#chapter-4.-pseudo-random-number-generators-best-practices",
    "href": "index.html#chapter-4.-pseudo-random-number-generators-best-practices",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Chapter 4. Pseudo-random number generators: best practices",
    "text": "Chapter 4. Pseudo-random number generators: best practices",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#chapter-5.-pseudo-random-number-generators-continuous-values-from-discrete-machines",
    "href": "index.html#chapter-5.-pseudo-random-number-generators-continuous-values-from-discrete-machines",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Chapter 5. Pseudo-random number generators: continuous values from discrete machines",
    "text": "Chapter 5. Pseudo-random number generators: continuous values from discrete machines",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#chapter-6.-virulence-transmission-trade-off-frank-1996",
    "href": "index.html#chapter-6.-virulence-transmission-trade-off-frank-1996",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Chapter 6. Virulence-transmission trade-off (Frank, 1996)",
    "text": "Chapter 6. Virulence-transmission trade-off (Frank, 1996)\nNo matching items",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "index.html#chapter-3.-basics-of-visualizing-mathematical-models",
    "href": "index.html#chapter-3.-basics-of-visualizing-mathematical-models",
    "title": "Learning (just enough) Julia for scientific informatics, modeling, and reasoning",
    "section": "Chapter 3. Basics of visualizing mathematical models",
    "text": "Chapter 3. Basics of visualizing mathematical models",
    "crumbs": [
      "Learning (just enough) Julia for scientific informatics, modeling, and reasoning"
    ]
  },
  {
    "objectID": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html#generating-sequences-of-values-using-the-range-function",
    "href": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html#generating-sequences-of-values-using-the-range-function",
    "title": "Basics of visualizing mathematical models",
    "section": "",
    "text": "This is an example of a mathematical model relating \\(y\\) values to \\(x\\):\n\nModel: A linear model\\(y = 6x + 4\\)\n\n\nTo visualize this in Julia, we generate sets \\(x\\) and \\(y\\) values conforming to the above relationship and pass these to the plotting function. These values may be generated systematically—a sequence generated by an algorithm—or stochastically—sampled from a probabilistic distribution. Here, we will discuss the first case.\nIn all cases, we have to ensure that the type and range of values conform to the assumptions of the model. In this example, The \\(x\\) and \\(y\\) values will be assumed to be, each, single-dimensional real values, \\(x, y \\in \\mathrm{R}^1\\), taking values in the entire real line. The \\(y\\) values here are deterministic functions of the \\(x\\) values, and so they can be calculated from the \\(x\\) values, once these have been generated.\n\n\n\n\n\n\n\n\n\n\nNoteRange objects are algorithmic representation of ranges\n\n\n\nThe actual value returned by the range function are not actually arrays of values, but rather a special “lazy” range object, with “lazy” here being a program design term meaning that the resources (particularly memory) will be allocated only if and when needed. What this means is that you can construct very large collections of values, with large ranges and high resolution, but not pay the resource cost of holding all these values in memory at the same time.\njulia&gt; r = range(1e-10, 1e10; step = 0.001)\n1.0e-10:0.001:1.0e10\njulia&gt; length(r)\n10000000000001\njulia&gt; r[begin]\n1.0e-10\njulia&gt; r[end]\n1.0e10\njulia&gt; r[begin + 2]\n0.0020000001\njulia&gt; r[end - 4]\n9.999999999996e9\njulia&gt; r[1]\n1.0e-10\njulia&gt; r[2]\n0.0010000001\njulia&gt; r[3]\n0.0020000001\nTo actually generate the values, use the collect function, which will “unpack” the range object and return a Vector object (a single dimensional array) with the full sequence of values.\njulia&gt; r = range(0, 10; step = 2.5)\n0.0:2.5:10.0\n\njulia&gt; collect(r)\n5-element Vector{Float64}:\n 0.0\n 2.5\n 5.0\n 7.5\n10.0\n\nWe can generate a set of \\(x\\) values over a particular range of values, continuous or otherwise, using the range function in Julia. The range function has a number of different methods, but for our purposes we will focus on specifying the range in terms of a three parameters: a start value, a stop value, and either a step size (interval between consecutive values in the sequence),\njulia&gt; range(0, 10; step = 1)\n0:1:10\njulia&gt; range(0, 10; step = 0.2)\n0.0:0.2:10.0\njulia&gt; range(-10, 10; step = 2)\n-10:2:10\nor length (number of values) in the sequence,\njulia&gt; range(0, 10; length = 11)\n0.0:1.0:10.0\njulia&gt; range(0, 10; length = 5)\n0.0:2.5:10.0\njulia&gt; range(-1, 1; length = 20)\nThe range function has a short-hand syntax, start:step:stop:\njulia&gt; 0.0:2.5:10.0\n0.0:2.5:10.0\n\njulia&gt; collect(0.0:2.5:10.0)\n5-element Vector{Float64}:\n  0.0\n  2.5\n  5.0\n  7.5\n 10.0\n\njulia&gt; 0.0:2.5:10.0 == range(0, 10; step = 2.5)\ntrue\n\n\n\n\n\n\n\n\n\n\nTipmap: to apply a function to every element in a collection\n\n\n\nThe map function applies a given function to every element of a collection, returning a new collection of the results. map(x -&gt; 6x + 4, x_values) passes each value in x_values through the function (here an anonymous function, defined using the arrow function definition syntax, x -&gt; 6x + 4), one at a time, producing a corresponding output value for each. This is a common and idiomatic pattern in Julia: rather than writing an explicit loop, you map a transformation over a collection. The result has the same length and order as the input.\n\n\n\n\n\n\n\nTipAnonymous vs. named functions\n\n\n\nNote that here we passed map an anonymous function.\nAn anonymous function is a function defined without a name, typically for immediate or one-time use, using the arrow syntax, which list the input arguments of the left of the -&gt; and output on the right. For example,x -&gt; x^2 is an anonymous function that squares its input, while (n_apples, price_of_apple) -&gt; n_apples * price_of_apple calculates the price of a collection of apples.\nAnonymous functions are most commonly used when a function is simple and only needed in one place, defining it anonymously is cleaner than giving it a name. Typically, as functions get more complex, or for documentation and replicability reasons, we often prefer to use named functions.\n\nmodel1(x) = 6x + 4\n\nfunction model2(x) \n  x^2 + 2x + 3\nend\n\nmap(model1, x_values)\nmap(model2, x_values)\n\n\nWe calculate the \\(y\\) values corresponding to each \\(x\\) value generated by the range object using the map function, and visualize the relationship between the \\(x\\) and \\(y\\) points using the scatter function from the CairoMakie library:\n\nusing CairoMakie\nx_values = -10:0.01:10\ny_values = map(x -&gt; 6x + 4, x_values)\nscatter(x_values, y_values)\n\n\n\n\nor, if we do not need to store the \\(y\\) values beyond the visualization:\nusing CairoMakie\nX = -10:0.01:10\nscatter(X, map(x -&gt; 6x + 4, X))\n\n\nExercise\nVisualize larger ranges and higher resolutions (smaller steps) of \\(x\\)-values of this same model\n\\[\ny = 6x + 4\n\\]\nto see if the relationships change:\n\n\\(-1000 &lt; x &lt; 1000\\), with step sizes of 1.0\n\\(0 &lt; x &lt; 1.0\\), with step sizes of 0.001\n\n\n\n\n\nExercise\nVisualize the following models in terms of the relationship between the varibles under the specified ranges:\n\n\\(f(x) = \\frac{1}{x}, x \\in \\{1, 2, \\ldots, 100\\}\\)\n\\(f(x) = x^2, -10 \\le x \\le 10\\)",
    "crumbs": [
      "Practicals",
      "Basics of visualizing mathematical models"
    ]
  },
  {
    "objectID": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html#plotting-containers-figure-and-axis-objects",
    "href": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html#plotting-containers-figure-and-axis-objects",
    "title": "Basics of visualizing mathematical models",
    "section": "2 Plotting containers: Figure and Axis objects",
    "text": "2 Plotting containers: Figure and Axis objects\n\nProficiencies\n\nFor pilot and exploratory work: plotting without explicit Figure and Axis objects.\nCreating a Figure container object to hold all the plots.\nCreating an Axis object onto which you will do the plotting, and placing it in a Figure object.\nUsing a stock plotting functions to plot given 2-dimensional data (\\(x-\\) and \\(y\\)-coordinates, for example).\nSaving the figure to a file or displaying it in-situ.\n\n\n\n\n2.1 Plotting with implict Axis and Figure\n\n\n# Load the graphical module\nusing CairoMakie\n\n# Generate x-values from 1 to 100\nx_vals = 1:100\n\n# Generate y-values from function applied to x-values\ny_vals = map(x -&gt; 3x + 2, x_vals)\n\n# Plot (and display) using the `scatter` function\nrender = scatter(x_vals, y_vals)\n\n# Save to file\n# save(\"scatter1.pdf\", render)\n# Show figure in the REPL\n# render.figure\n\n\n\n\n\n\n2.2 Plotting with explicit Axis and Figure management\n\n# Load the graphical module\nusing CairoMakie\n\n# Create a `Figure` object\nfigure = Figure();\n\n# Create an `Axis` object, placing it in the center of the figure.\n# `[1, 1]` specifies cell (1, 1) of a grid that grows dynamically as \n# cells are specified. Here, as there is only one cell defined, it\n# effectively places the `Axis` object in the center of the `Figure`\n# object\nax = Axis(figure[1, 1])\n\n# Plot some data onto the Axis object\n\n# x-coordinate values: a sequence from 0.0 to 100.0, in 0.01 step increments\nx_vals = 0:0.1:100.0\n\n# y-coordinate values: a function of the x-coordinate values\n#\n# $$\n# y = 4 x^2 + 2 x + 3\n# $$\n#\ny_vals = map(x -&gt; 4(x^2) + 2x + 3, x_vals)\n\n# Plot using the `scatter!` function\n# Note: the name is `scatter!` not `scatter`, and we pass \n# in the Axis object `ax` as the first argument\nscatter!(ax, x_vals, y_vals)\n\n# Save to file\n# save(\"scatter1.pdf\", render)\n# Show figure in the REPL\n# render.figure\n\nScatter{Tuple{Vector{Point{2, Float64}}}}",
    "crumbs": [
      "Practicals",
      "Basics of visualizing mathematical models"
    ]
  },
  {
    "objectID": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html#visualizing-the-single-strain-parasite-virulence-transmission-balance-fitness-landscape",
    "href": "content/01_practicals/03_basics-of-visualizing-mathematical-models/index.html#visualizing-the-single-strain-parasite-virulence-transmission-balance-fitness-landscape",
    "title": "Basics of visualizing mathematical models",
    "section": "3 Visualizing the single-strain parasite virulence-transmission balance fitness landscape",
    "text": "3 Visualizing the single-strain parasite virulence-transmission balance fitness landscape\n\n3.1 Parasite fitness function\n\nThe single-strain parasite fitness model is given as (Frank 1996):\nAs discussed in ?@sec-markov-property, the defining condition only depends on the present state.\n\\[\n\\begin{aligned}\nw = z (1 - \\alpha z)\n\\end{aligned}\n\\tag{1}\\]\nwhere:\n\n\\(w\\) is a measure of parasite fitness,\n\\(z\\) is a measure of the parasite host exploitation severity, correlating positively with parasite reproductive and host colonization capacity, and\n\\(\\alpha z\\) is a measure of virulence, the damage a parasite does to the host as a result of exploitation \\(z\\), with \\(\\alpha\\) a scaling factor, weighting the damage of the parasite reproductive activity in reducing the host resources available to the parasite.\n\n\n\n3.2 Behavior under adaptive evolution\nLet us consider host exploitation severity, \\(z\\), as a heritable trait that affects transmission success and virulence, and let \\(w(z, \\alpha)\\) be the fitness of of a parasite with host exploitation severity trait value \\(z\\), given some virulence impact weight \\(\\alpha\\).\nIf parasites vary in \\(z\\) and this variation is heritable, then strategies with larger \\(w(z)\\) tend to leave more descendants (i.e., spread more effectively).\nIn this simplified model, we therefore expect evolution to favor values of \\(z\\) that make \\(w(z)\\) as large as possible, so we look for the value of \\(z\\) that maximizes \\(w(z)\\).\nConceptually, we can treat \\(z\\) as a control or tuning variable: it is the parasite strategy we imagine changing. The parameter \\(\\alpha\\) determines how strongly exploitation reduces host resources (how costly virulence is per unit increase in \\(z\\)). For a fixed \\(\\alpha\\), plotting \\(w\\) against \\(z\\) shows a trade-off: increasing \\(z\\) raises transmission potential, but beyond a point the virulence cost dominates and \\(w\\) declines.\n\n\n3.3 Visualization of fitness relationship with host exploitation severity\n\nProficiencies\n\nGenerating a 1D grid of input values with range (or start:step:stop).\nComputing model outputs over a grid with map.\nPlotting a single 2D relationship with an implicit figure/axis (quick exploratory plot).\nCreating an explicit Figure and Axis, and adding multiple curves to the same axis with ...! plotting functions.\nVisualizing a 2-parameter model as a surface by evaluating the model on a 2D grid.\n\n\n\nWe will visualize the single-strain fitness model\n\\[\nw(z;\\alpha) = z(1-\\alpha z),\n\\]\nwhere:\n\n\\(z\\) is host exploitation severity (the model’s adjustable trait variable),\n\\(\\alpha\\) is a fixed scaling parameter that determines how strongly exploitation reduces transmission opportunity,\n\\(w\\) is parasite fitness (new infected hosts per infected host under the model).\n\nIn Julia, we can generate a grid of \\(z\\) values, evaluate \\(w(z;\\alpha)\\), and plot \\(w\\) versus \\(z\\) for one or several choices of \\(\\alpha\\).\nWhen we plot \\(w\\) versus \\(z\\) for a fixed \\(\\alpha\\), we typically restrict to\n\\[\n0 \\le z \\le \\frac{1}{\\alpha},\n\\]\nso that the transmission-opportunity term \\((1-\\alpha z)\\) stays nonnegative.\n\n\n3.4 Single \\(\\alpha\\), implicit plot (quick exploratory)\n\nusing CairoMakie\n\n# Fitness model\nw(z, α) = z * (1 - α*z)\n\n# Choose a single α value\nα = 0.5\n\n# Generate z-values over the biologically meaningful range\nz_vals = range(0.0, 1/α; length = 400)\n\n# Evaluate the model on the grid\nw_vals = map(z -&gt; w(z, α), z_vals)\n\n# Quick plot with implicit Figure/Axis\nlines(z_vals, w_vals)\n\n\n\n\nThis produces one curve showing how fitness changes as host exploitation severity \\(z\\) increases, holding \\(\\alpha\\) fixed.\nMultiple \\(\\alpha\\) values on the same plot (explicit Figure and Axis) using CairoMakie\n\n# Fitness model\nw(z, α) = z * (1 - α*z)\n\n# Choose several α values to compare\nα_values = [0.2, 0.5, 1.0]\n\n# Create Figure and Axis explicitly\nfig = Figure()\nax = Axis(\n    fig[1, 1],\n    xlabel = \"host exploitation severity (z)\",\n    ylabel = \"parasite fitness (w)\",\n    title  = \"Fitness curves for different α\"\n)\n\n# Add one curve per α onto the same axis\nfor α in α_values\n    z_vals = range(0.0, 1/α; length = 400)\n    w_vals = map(z -&gt; w(z, α), z_vals)\n    lines!(ax, z_vals, w_vals, label = \"α = $(α)\")\nend\n\n# Add a legend\naxislegend(ax)\n\nfig\n\n\n\n\nHere, \\(\\alpha\\) plays the role of a parameter you “sweep” across several values, to see how the \\(w\\)–\\(z\\) relationship changes.\nSurface plot: fitness as a function of \\(z\\) and \\(\\alpha\\)\nTo visualize the full two-parameter relationship \\(w(z;\\alpha)\\), we evaluate \\(w\\) on a 2D grid of \\((z,\\alpha)\\) values and plot a surface.\n\nusing CairoMakie\n\n# Fitness model\nw(z, α) = z * (1 - α*z)\n\n# Grid of α values (parameter axis)\nα_vals = range(0.2, 1.0; length = 120)\n\n# Grid of z values (trait axis)\n# Use a common z-range for the surface; choose up to 1/max(α) so the full grid is comparable\nz_max = 1 / maximum(α_vals)\nz_vals = range(0.0, z_max; length = 200)\n\n# Evaluate w on the (z, α) grid:\n# W[i, j] = w(z_vals[i], α_vals[j])\nW = [w(z, α) for z in z_vals, α in α_vals]\n\n# Plot as a 3D surface\nfig = Figure()\nax3 = Axis3(\n    fig[1, 1],\n    xlabel = \"host exploitation severity (z)\",\n    ylabel = \"virulence scaling (α)\",\n    zlabel = \"parasite fitness (w)\",\n    title  = \"Fitness surface w(z; α)\"\n)\n\nsurface!(ax3, z_vals, α_vals, W)\n\nfig\n\n\n\n\nThis surface makes it visually explicit that \\(w\\) depends on both the trait value (\\(z\\)) and the environment/biology scaling parameter (\\(\\alpha\\)).\n\nExerciseSingle-curve practice (implicit plot)\nSet \\(\\alpha = 0.25\\) and reproduce the single-curve plot.\nIncrease the resolution by changing length = 400 to length = 2000.\nRestrict the plotted domain to \\(0 \\le z \\le \\frac{1}{2\\alpha}\\) and compare the shape to the full range \\(0 \\le z \\le \\frac{1}{\\alpha}\\).\n\n\n\nExerciseMultiple-curve practice (explicit Axis, adding curves)\nPlot curves for \\(\\alpha \\in {0.1, 0.2, 0.4, 0.8}\\) on the same axis.\nAdd a second axis below the first that plots the same curves using scatter! instead of lines!.\nChange axis labels and title so that the plot reads well when exported.\n\n\n\nExerciseSurface practice (2D grid evaluation)\nChange the \\(\\alpha\\) grid to range(0.1, 2.0; length = 200) and regenerate the surface.\nReplace the surface with a heatmap of \\(w\\) over \\((z,\\alpha)\\) using heatmap!(…).\nModify the grid so that, for each \\(\\alpha\\), you only include \\(z \\le 1/\\alpha\\) (the nonnegative-opportunity region) by setting \\(w(z,\\alpha) = NaN\\) whenever \\(z &gt; 1/\\alpha\\), and observe how the plotted region changes.",
    "crumbs": [
      "Practicals",
      "Basics of visualizing mathematical models"
    ]
  },
  {
    "objectID": "content/01_practicals/index.html#chapter-3.-basics-of-visualizing-mathematical-models",
    "href": "content/01_practicals/index.html#chapter-3.-basics-of-visualizing-mathematical-models",
    "title": "Practicals",
    "section": "",
    "text": "NoteDetails\n\n\n\n\n\n\n\n\nSynopsis\nRequirements\nReferences\n\n\n\n\n\n\nModel: Single-lineage parasite virulence evolution",
    "crumbs": [
      "Practicals"
    ]
  }
]